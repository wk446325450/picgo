---
title: 计算机组成原理
date: 2023-10-18T00:16:48Z
lastmod: 2023-11-30T01:52:07Z
---

# 计算机组成原理

# 第1章计算机系统概论

## 1.1计算机发展历程

### 1.1.0什么是计算机系统

​![image.png](assets/net-img-202310180016500-20231113184534-5luiqa7.png)​

​![image.png](assets/net-img-202310180016501-20231113184534-kpo60t5.png)​

### 1.1.1计算机硬件的发展

#### 1.计算机的四代发展

|发展阶段|时间|迭代|逻辑元件|速度（次/秒）|内存（主存）|外存（辅存）|编程语言|操作系统发展|
| ----------| -----------| ----------------------| ----------------------------------| ---------------| ----------------------------------------| --------------------------------| --------------------------------| ---------------------------------------------------------|
|第一代|1946-1957|电子管时代|电子管|几千-几万|汞延迟线，磁鼓|穿孔卡片，纸带|机器语言||
|第二代|1958-1964|晶体管时代|晶体管|几万-几十万|磁芯存储器|磁带|开始出现高级语言及其编译程序；|有了操作系统的雏形|
|第三代|1964-1971|中小规模集成电路时代|中小规模集成电路|几十万-几百万|半导体存储器<br />（开始取代磁芯存储器）<br />|磁带，磁盘|高级语言发展迅速；|操作系统进一步发展，出现分时操作系统|
|第四代|1971-现在|超大规模集成电路时代|大规模集成电路和超大规模集成电路|上千万-万亿|半导体存储器|磁带，磁盘，光盘，半导体存储器||产生了微处理器（cpu），微型计算机，个人计算机（pc）萌芽|

> 微型计算机的发展以（==微处理器技术==）为标志

#### 2.计算机元件的更新换代

* **什么是机器字长？**

  * **==机器字长：计算机一次整数运算所能处理的二进制位数。==**
  * 就是我们说的8位，16位，32位，64位

​![image.png](assets/net-img-202310180016504-20231113184535-zm0oqdz.png)​

​![image.png](assets/net-img-202310180016505-20231113184536-efj5nih.png)​

### 1.1.2计算机软件的发展

### 1.1.5目前的发展趋势

​![image.png](assets/net-img-202310180016506-20231113184536-an9gs52.png)​

### 本节回顾

​![image.png](assets/net-img-202310180016507-20231113184537-ecyp8cy.png)​

## 1.2计算机的层次结构⭐⭐

### 1.2.1计算机系统的组成

* **硬件系统和软件系统**共同构成了一个**完整的计算机系统**。

  * 硬件是指**有形的物理设备**,是计算机系统中实际物理装置的总称。
  * 软件是指在**硬件上运行的程序和相关的数据及文档。**
* 计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。
* **对某一功能来说，其既可以用软件实现，又可以用硬件实现**，则称为软硬件在逻辑上是等效的。
* 在设计计算机系统时，要进行软/硬件的功能分配。通常来说，**一个功能若使用较为频繁且用硬件实现的成本较为理想，使用硬件解决可以提高效率。**

* 硬件：成本高，效率高；软件：成本低，效率低。

### 1.2.2计算机硬件

​![image.png](assets/net-img-202310180016509-20231113184537-4ees11b.png)​

#### 冯·诺依曼机⭐

* **冯·诺伊曼机的特点**：

  * 1)采用"**存储程序** **&quot;** 的工作方式。
  * 2)计算机硬件系统由**运算器，存储器，控制器，输入设备和输出设备**5大部件组成。
  * 3)**指令和数据**以同等地位存储在**存储器**中，形式上没有区别，但计算机应能区分它们；可**按地址访存**
  * 4)**指令和数据**均用二进制代码表示。**指令由操作码和地址码组成**，**操作码指出**​**操作的类型** **，地址码指出**​**操作数的地址** **。**
  * 5)以**运算器**为中心
* **存储程序**的概念

  * 课本版："存储程序"的基本思想是：==将事先编制好的程序和原始数据以二进制代码形式 送入主存（主存储器/内存）后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束==。以此概念为基础的各类计算机统称为冯·诺依曼机
  * 电子版：“存储程序”的概念是指==将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。==

​![image.png](assets/net-img-202310180016511-20231113184538-iwynfm3.png)​​  
  

#### 现代计算机的结构和硬件组成⭐

​![image.png](assets/net-img-202310180016513-20231113184539-39qcn5v.png)​

​![image.png](assets/net-img-202310180016514-20231113184539-6ale49a.png)​

#### 2.计算机的功能部件

​![image.png](assets/net-img-202310180016515-20231113184540-1ce0y4t.png)​

##### （1）输入设备：将信息转换成机器能识别的形式

* 输入设备的主要功能是**将**​**程序和数据****以**​**机器****所能识别和接受的信息形式输入计算机**。
* 最常用也最基本的输入设备是键盘，此外还有鼠标，扫描仪，摄像机等。

##### （2）输出设备：将结果转换成人们熟悉的形式

* 输出设备输出设备的任务是将计算机处理的结果以**人们所能接受的形式或其他系统所要求的信息形式**输出。
* 最常用，最基本的输出设备是显示器，打印机。输入/输出设备（简称I/O设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。

##### （3）存储器：存放数据和程序

1. 存储器分为**主存储器（又称内存储器）和辅助存储器(又称外存储器)。**
2. **CPU能够直接访问的存储器是主存储器。** 辅助存储器用于帮助主存储器记忆更多的信息，**辅助存储器中的信息必须调入主存后，才能为CPU所访问。**

###### （i）主存储器⭐

​![image](assets/net-img-202310191718408-20231113184540-hsydm9n.png)​![image](assets/net-img-202310191806917-20231113184541-m9x8uis.png)​​​

* 主存储器的**最基本组成**：**存储体，MAR，MDR，时序控制逻辑** **。**
* 主存储器**各部件基本功能**：

  * 存储体存放**二进制信息**，
  * **地址寄存器(MAR）** 存放**访存地址**，经过**地址译码**后找到所选的存储单元。
  * **数据寄存器(MDR）** 用于**暂存要从存储器中读或写的信息**，
  * **时序控制逻辑**用于**产生存储器操作所需的各种时序信号**。
* 主存储器的**工作方式****是按存储单元的地址进行存取,这种存取方式称为**​**按地址存取方式** **。**
* 🐖：**地址译码器**也是主存的构成部分

###### （ii）主存储器中的基本概念⭐

​![image.png](assets/net-img-202310180016518-20231113184541-dm957xy.png)​

**注意：存储字和字应该不一样**

* **存储单元**：**存储体**由许多**存储单元**组成，每个**存储单元**包含**若干存储元件**，每个存储元件存储一位二进制代码“0”或“1”。
* **存储字与存储字长**：存储单元可存储一串二进制代码，称这串代码为**存储字**，称这串代码的位数为**存储字长**，存储字长可以是**1B (8bit）或是字节的偶数倍** **。**
* **MAR用于寻址**，其位数对应着**存储单元的个数**，如 MAR为10位，则有2^10^=1024个存储单元，记为1K。**MAR的长度与PC的长度相等**。
* **MDR的位数**和**存储字长**相等，一般为**字节的二次幂的整数倍**。
* 注意:**MAR与MDR**虽然是存储器的一部分，但在现代计算机中却是**存在于CPU**中的;另外，后文提到的**高速缓存(Cache）也存在于CPU中**。

##### （4）运算器：算术运算和逻辑运算⭐

​![image.png](assets/net-img-202310180016520-20231113184542-bon6rbt.png)​

* 运算器是计算机的执行部件，用于进行**算术运算**和**逻辑运算**。**算术运算**是按算术运算规则进行的运算，如加、减、乘、除; **逻辑运算**包括与、或、非、异或、比较、移位等运算。
* 运算器的核心是**算术逻辑单元(Arithmetic and Logical Unit，ALU)** 。运算器包含**若干通用寄存器** **，用于**​**暂存操作数和中间结果** **，如**​**累加器(ACC)、乘商寄存器(MQ)、操作数寄存器(X)、** **变址寄存器(IX)、基址寄存器(BR）等，其中**​**前3个寄存器是必须具备****的。**
* **运算器内还有**​**程序状态寄存器(PSW)**  **，也称**​**标志寄存器**，这也是**寄存器**，用于**存放ALU运算得到的一些**​**标志信息或处理机的状态信息** **，如结果是否溢出、有无产生进位或借位、结果是否为负等**。

##### （5）控制器：指挥程序运行⭐

​![image.png](assets/net-img-202310180016521-20231113184542-fy5zg2v.png)​

* 控制器是**计算机的指挥中心**，由其“指挥”各部件自动协调地进行工作。

* 控制器由**程序计数器（PC)** 、**指令寄存器（IR）** 和**控制单元（CU)** 组成。
* PC用来存放当前**欲执行指令的地址**，可以自动加1以形成下一条指令的地址，**它与主存的MAR之间有一条直接通路**。
* **注意：pc是一种特殊寄存器**
* IR用来存放**当前执行的指令**，其内容来自主存的MDR。指令中的**操作码OP(IR)送至CU**，用以分析指令并发出各种微操作命令序列；而**地址码Ad(IR)送往MAR**，用以取操作数。
* 一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU)。CPU和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O设备等）统称为外部设备，简称外设。

​![image.png](assets/net-img-202310180016522-20231113184543-oj1ipzr.png)​

* 图中从**控制器**送出的**虚线就是控制信号**，可以控制如何修改**PC**以得到下一条指令的地址，可以控制ALU执行什么运算，可以控制主存是进行读操作还是写操作（读/写控制信号)。
* **MAR与MDR虽然是存储器的一部分，但在现代计算机中却是存在于CPU中的**；

* CPU和主存之间通过一组总线相连，总线中有地址、控制和数据3组信号线。

* MAR中的地址信息会**直接送到地址线**上，用于指向读/写操作的主存存储单元；控制线中有读/写信号线，指出数据是从CPU写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将**MDR**中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。

##### ⭐计算机的工作过程模拟：y=ab+c，a=2，b=3，c=1，y=0。

* 注意 **:(PC)指程序计数器PC中存放的内容。PC→MAR应理解为(PC)→MAR，即程序计数器中的值经过数据通路送到MAR，也即表示数据通路时括号可省略（因为只是表示数据流经的途径，而不强调数据本身的流动)。**​**但****运算时括号不能省略，即(PC)+1→PC不能写为PC+1→PC。当题目中(PC)→MAR的括号未省略时，考生最好也不要省略。**

​![y=ab+c.png](assets/net-img-202310180016523-20231113184543-fjcedkd.png)​

​![y=ab+c---(2).png](assets/net-img-202310180016524-20231113184544-8e667e4.png)​

​![y=ab+c---(3).png](assets/net-img-202310180016525-20231113184544-e9iv5ha.png)​

​![y=ab+c---(4).png](assets/net-img-202310180016526-20231113184545-1f2czru.png)​

​![y=ab+c---(5).png](assets/net-img-202310180016527-20231113184545-pzdb2vu.png)​

###### 补充：cpu如何区分指令和数据？

​![image.png](assets/net-img-202310180016528-20231113184546-dz3eebb.png)​

##### 本节总结

​![image.png](assets/net-img-202310180016529-20231113184547-mmjshg7.png)​

### 本节回顾

​![image.png](assets/net-img-202310180016530-20231113184547-nuimew8.png)​

### 1.2.3计算机软件+1.2.4计算机系统的层次结构

#### 1.系统软件和应用软件

* 软件**按其功能分类**，可分为**系统软件和应用软件**。

  * 系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要有**操作系统（OS)、数据库管理系统（DBMS)、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等**。
  * 应用软件是指用户为解决某个应用领域中的各类问题而编制的**程序**，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。

#### 2.三种级别的语言

​![image.png](assets/net-img-202310180016531-20231113184549-sn6lurh.png)​

* 机器语言。又称**二进制代码语言**，需要编程人员记忆每条指令的二进制编码。**机器语言是计算机唯一可以直接识别和执行的语言**。
* 汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。
* 高级语言。高级语言（如C、C++t、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，**或**直接由高级语言程序翻译成机器语言程序。
* **注意：编译程序可以直接把高级语言编译成机器语言**，**解释程序也可以**

#### 3.软件和硬件的逻辑功能等价性

* 硬件实现的往往是最基本的算术和逻辑运算功能，而其他功能大多通过软件的扩充得以实现。
* **对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为**​**软、硬件逻辑功能的等价性** **。** 例如，浮点数运算既可以用专门的浮点运算器硬件实现，又可以通过一段子程序实现，这两种方法在功能上完全等效，不同的只是执行时间的长短而已，显然**硬件实现的性能要优于软件实现的性能**。
* 软件和硬件逻辑功能的等价性是计算机系统设计的重要依据，软件和硬件的功能分配及其界面的确定是计算机系统结构研究的重要内容。当研制一台计算机时，设计者必须明确分配每一级的任务，确定哪些功能使用硬件实现，哪些功能使用软件实现。软件和硬件功能界面的划分是由设计目标、性能价格比、技术水平等综合因素决定的。

#### 4.计算机系统的层次结构

​![image.png](assets/net-img-202310180016533-20231113184550-hu5y4ld.png)​

​![image.png](assets/net-img-202310180016534-20231113184551-cssx4lk.png)​

* 没有配备软件的纯硬件系统称为**裸机**。

* 第3层～第5层称为虚拟机，简单来说就是软件实现的机器。虚拟机器只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者米说，**只能通过该层的语言来了解和使用计算机，而不必关心下层是如何工作的。**

* 层次之间的关系紧密，**下层是上层的基础，上层是下层的扩展** **。** 随着超大规模集成电路技术的不断发展，部分软件功能将由硬件来实现，因而软/硬件交界面的划分也不是绝对的。

* 本门课程主要讨论传统机器M1和微程序机器MO的组成原理及设计思想。

#### 总结

​![image.png](assets/net-img-202310180016535-20231113184551-p7lages.png)​

## 1.3计算机性能指标⭐⭐

### 1.3.1计算机的主要性能指标⭐

#### 1.字长

* **字长****是指**​**计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数**，通常与CPU 的寄存器位数、加法器有关。**因此，字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8位）的整数倍。**
* **注意:机器字长、指令字长和存储字长的关系**1.5常见问题和易混淆知识点⭐

#### 2.数据通路带宽

* **数据通路带宽****是指**​**数据总线一次所能并行传送信息的位数**。**这里所说的数据通路宽度是指**​**外部数据总线的宽度** **，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。**
* **注意:各个子系统通过数据总线连接形成的数据传送路径称为**​**数据通路** **。**

#### 3.主存容量

​![image.png](assets/net-img-202310180016542-20231113184555-63v2jaa.png)​

​![image.png](assets/net-img-202310180016543-20231113184556-izwke6n.png)​

#### 4.运算速度⭐

​![image.png](assets/net-img-202310180016554-20231113184600-jz1luhx.png)​

##### （1）吞吐量和响应时间

* 吞吐量：指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此**系统吞吐量主要取决于主存的存取周期。**
* **响应时间**：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括 **CPU 时间**(运行一个程序所花费的时间) 与**等待时间**(用于磁盘访问、存储器访问、I/O 操作、操作系统开销等的时间)。

##### （2）主频和CPU时钟周期

* **CPU 时钟周期**：通常为节拍脉冲或 T周期，即**主频的倒数**，**它是 CPU 中最小的时间单位**，**执行指令的每个动作至少需要 1 个时钟周期**。

* **主频(CPU 时钟频率/CPU主频）** ：机器内部主时钟的频率，是衡量机器速度的重要参数；

  * 也可定义为**CPU内数字脉冲信号震荡的频率/单位时间脉冲信号的数目/**​**单位时间时钟周期数**。
  * 对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短执行指令的速度越快。
  * 例如，常用 CPU 的主频有 1.8GHZ、2.4GHZ、2.8GHz等
* **注意:CPU 时钟周期 = 1/主频，**​**主频****通常以 Hz(赫兹)为单位，**​**1Hz表示每秒1次**​​

##### （3）CPI

* **CPI：**​**执行一条指令所需的时钟周期数** **；**
* **注意：不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其CPI指该程序或该机器指令集中的所有指令执行所需的**​**平均时钟周期数** **，此时**​**CPI是一个平均值** **。**

##### （4）CPU执行时间⭐

* **CPU执行时间：**​**指运行一个程序所花费的时间。**

* **CPU执行时间=**​**CPU时钟周期数/主频=(指令条数×CPI)/主频**
* 上式表明，**CPU 的性能(CPU 执行时间)** 取决于三个要素

  * ①主频(时钟频率)
  * ②每条指令执行所用的时钟周期数(CPI)
  * ③ 指令条数
* 主频、CPI和指令条数是相互制约的。​

###### 例题

​![image.png](assets/net-img-202310180016548-20231113184558-foa9ct7.png)​

##### （5）IPS MIPS MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS 和 ZFLOPS。⭐

* **IPS：**​**每秒执行多少条指令**，**IPS=主频/平均CPI**（**单位时间时钟周期数/每条指令的时钟周期数=单位时间时钟周期数**）。

* **MIPS：**​**每秒执行多少百万条指令，MIPS=指令条数/（执行时间*10**^**6**^ **）=主频/（CPI*10**^**6**^ **）**

* ​![image.png](assets/net-img-202310180016551-20231113184559-b7uk41r.png)​

* ​![image.png](assets/net-img-202310180016552-20231113184559-2q1855v.png)​

* ​![image.png](assets/net-img-202310180016553-20231113184559-b3tbwgs.png)

##### 补充：常见2的n次方与K M G T

​![image.png](assets/net-img-202310180016555-20231113184600-6k13427.png)​

​![image.png](assets/net-img-202310180016556-20231113184601-8ozkry9.png)​

**上面，这里的单位应该是字节，而不是bit；1KB=2的10次方B，1Kb=2的10次方b；**

​![image.png](assets/net-img-202310180016557-20231113184601-310dkjj.png)​

#### 5.基准程序​​

* ****是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。

​![image.png](assets/net-img-202310180016559-20231113184602-vegxdmi.png)​

#### 问题

​![image.png](assets/net-img-202310180016560-20231113184602-bd9bubu.png)​

​![image.png](assets/net-img-202310180016561-20231113184603-96f826m.png)​

​![image.png](assets/net-img-202310180016562-20231113184603-9afcdod.png)​

#### 总结

​![image.png](assets/net-img-202310180016563-20231113184604-e8hpcvt.png)​

### 1.3.2几个专业术语

* 1）系列机。具有基本相同的体系结构，使用**相同基本指令系统**的多个**不同型号的计算机**组成的一个产品系列。
* 2）兼容。指**软件或硬件的通用性**，即运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。
* 3）软件可移植性。指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。
* 4）固件：**将程序固化在 ROM中组成的部件称为固件**。固件是一种具有软件特性的硬件，吸收了软/硬件各自的优点，**其执行速度快于软件，灵活性优于硬件**，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于ROM中)。

## 1.4本章小结

​![image.png](assets/net-img-202310180016564-20231113184604-t0v594l.png)​

## 1.5常见问题和易混淆知识点⭐

​![image.png](assets/net-img-202310180016565-20231113184605-921q0w6.png)​

​![image](assets/image-20231130014234-stylmin.png)​

​![image](assets/image-20231130014245-zj8sqlo.png)​

**取址周期不就是个机器周期吗？**

​![image](assets/image-20231130014312-n47flmb.png)​

​![image](assets/image-20231130014329-9mcfmop.png)​​​

# 第2章数据的表示与运算

![image.png](assets/net-img-202310180016567-20231113184606-0clcqag.png)

## 2.1数制与编码

### 2.1.1进位计数制及其相互转化

在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点：
1）二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，
制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示О和1。
2）二进制位1和О正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的
逻辑判断提供了便利条件。
3）二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。

#### 1.进位计数制

常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。
![image.png](assets/net-img-202310180016568-20231113184606-tcqpu5i.png)
在进位计数法中，每个数（码）位所用到的不同数码的个数称为**基数**。十进制的基数为10 (0~9)，每个数位计满10就向高位进位，即“逢十进一”。
十进制数101，其个位的1显然与百位的1所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为**位权**。一个进位数的数值大小就是它的各位数码按权相加。
![image.png](assets/net-img-202310180016569-20231113184607-8jmgp7v.png)

#### 2.不同进制之间的相互转换

##### （1）二进制转化为八进制和十六进制

对于一个二进制混合数（既包含整数部分，又包含小数部分)，在转换时应以小数点为界。其整数部分，从小数点开始往左数，将一串二进制数分为3位(八进制）一组或4位（十六进制）一组，在数的最左边可根据需要加“O”补齐;对于小数部分，从小数点开始往右数，也将一串二进制数分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为3或4的整数倍，然后分别用对应的八进制数或十六进制数取代。
**例子：** 
![image.png](assets/net-img-202310180016570-20231113184607-8myhqg9.png)
同样，由八进制数或十六进制数转换成二进制数，只需将每位改为3位或4位二进制数即可(必要时去掉整数最高位或小数最低位的0)。**八进制数和十六进制数之间的转换也能方便地实现，十六进数制转换为八进制数（或八进制数转换为十六进制数〉时，先将十六进制(八进制）数转换为二进制数，然后由二进制数转换为八进制(十六进制）数较为方便。** 

##### (2）任意进制数转换为十进制数

![image.png](assets/net-img-202310180016571-20231113184607-p2zntos.png)

##### (3)十进制数转换为任意进制数

​![image.png](assets/net-img-202310180016572-20231113184608-65gwy6r.png)  
​![image.png](assets/net-img-202310180016573-20231113184608-ws6r5fz.png)  
**二进制是B，八进制是O，十六进制是H**  
**若是10进制转化为8进制，可以先转成2进制，再转成8进制**  
**例题：**   
​![image.png](assets/net-img-202310180016574-20231113184608-z099pl5.png)​

​![image.png](assets/net-img-202310180016575-20231113184609-zz8d9d6.png)​

​![image.png](assets/net-img-202310180016576-20231113184609-urh3541.png)​

**补充：拼凑法，用于十进制转化为二进制**
![image.png](assets/net-img-202310180016578-20231113184610-idjwyxu.png)

#### 3.真值与机器数

![image.png](assets/net-img-202310180016579-20231113184610-3q0akv5.png)
![image.png](assets/net-img-202310180016580-20231113184610-m9tpe37.png)

### 总结

![image.png](assets/net-img-202310180016581-20231113184611-0wjtqg8.png)

### 2.1.2 BCD码

‍

#### 1.常见的BCD码

#####  **（1）8421码---有权码**

​![image.png](assets/net-img-202310180016584-20231113184611-t0sref3.png)​

​![image.png](assets/net-img-202310180016585-20231113184612-zos6gk2.png)​

#####  **（2）余3码---无权码**

​![image.png](assets/net-img-202310180016586-20231113184612-chqbbj0.png)​

#####  **（3）2421码----有权码**

​![image.png](assets/net-img-202310180016587-20231113184613-n0s933x.png)​

### 总结

​![image.png](assets/net-img-202310180016588-20231113184613-202n730.png)​

### 2.1.4整数的表示

#### 1.无符号整数的表示（在计算机中的表示与运算）

​![image.png](assets/net-img-202310180016603-20231113184614-0ikjoso.png)​

​![image.png](assets/net-img-202310180016604-20231113184614-ci28cop.png)​

​![image.png](assets/net-img-202310180016605-20231113184615-lhkh5v3.png)​

**无符号整数的表示**

​![image.png](assets/net-img-202310180016606-20231113184615-nhwzjfw.png)**每个数值位都是  位权*数值位的数值  当都是1是 最大为 ：2的n次方 -1**

##### 无符号整数的加法

![image.png](assets/net-img-202310180016607-20231113184616-zxxn12a.png)

##### 无符号整数的减法，转化为加法（“减数”全部位按位取反+1）

![image.png](assets/net-img-202310180016608-20231113184617-1j8n7l7.png)
![image.png](assets/net-img-202310180016609-20231113184617-zdt5y4o.png)

##### 总结

![image.png](assets/net-img-202310180016610-20231113184618-35xcm3i.png)

#### 2.带符号整数（在计算机中的表示与运算）（原/反/补三种编码方式）

​![image.png](assets/net-img-202310180016612-20231113184618-6bfvzuy.png)​

​![image.png](assets/net-img-202310180016613-20231113184619-6febu9t.png)  

##### 1.原码表示（加减法时转化为补码）

​![image.png](assets/net-img-202310180016614-20231113184619-a40368g.png)​

**原码的正负只是符号不同**  
​![image.png](assets/net-img-202310180016615-20231113184620-buqwh8t.png)​  
**原码因为符号位的原因，加减法不能直接加减----&gt;转化为补码**

##### 2.原码--->反码---->补码

**正数不变，负数  按位取反+1**
![image.png](assets/net-img-202310180016616-20231113184620-g38jk67.png)

###### a.补码与原码快速转化（负数补码）

![image.png](assets/net-img-202310180016617-20231113184621-gc8cd43.png)

##### 2.原码的加法---->补码的加法

**注意：正数的补码是它本身:** ![image.png](assets/net-img-202310180016618-20231113184621-xcm51er.png)**注意：补码的加法符号位参与运算**![image.png](assets/net-img-202310180016619-20231113184622-fspio4w.png)**得出来的结果为补码，转化为原码（正数就不用了）**

**注意：1.加法时，转化为补码，计算结果为补码，要转回原码**         **2.正数与负数的补码是不同的**

##### 3.原码的减法--->补码的减法------>补码的加法

###### a.正负补码的快速转化

​![image.png](assets/net-img-202310180016620-20231113184622-rf0yp63.png)​

​![image.png](assets/net-img-202310180016621-20231113184623-4blybhj.png)​

###### b.对比无符号正数的减法

![image.png](assets/net-img-202310180016622-20231113184623-x3aqg38.png)

##### 总结，原反补互相转化⭐

​![image.png](assets/net-img-202310180016623-20231113184624-2i8nrcp.png)​

##### 4.原反补移码的特性对比-各码表示范围⭐⭐

​![image.png](assets/net-img-202310180016624-20231113184624-z6dswvg.png)​

‍

​![image.png](assets/net-img-202310180016625-20231113184625-2o4h55i.png)​

**n+1bit一共2**​^**n+1**^​**个数**

​![image.png](assets/net-img-202310180016626-20231113184625-6r93aic.png)​

**注意：他们数的个数都是2**​**^n+1^**​**个吧？**

##### 5.移码

​![image.png](assets/net-img-202310180016627-20231113184626-4898gvn.png)​

​![image.png](assets/net-img-202310180016628-20231113184626-mjsi4xm.png)​

​![image.png](assets/net-img-202310180016629-20231113184627-4ehe7v7.png)​

#### 3.用几种码表示整数

​![image.png](assets/net-img-202310180016630-20231113184627-h60tnif.png)​

### 2.1.5定点小数

​![image.png](assets/net-img-202310180016631-20231113184628-7s6oha7.png)​

​![image.png](assets/net-img-202310180016632-20231113184628-64mguzu.png)  
**定点整数与定点小数一个**​ **== ，==**​ ** 一个 **​ **== .==**

#### 1.定点小数的原反补码转换；x的补码与-x的补码快速转化

![image.png](assets/net-img-202310180016633-20231113184629-806gn5e.png)

#### 2.定点小数的加减法

​![image.png](assets/net-img-202310180016634-20231113184629-hkcgypy.png)​  
**注意：与定点整数的加减法只有解读不同**

### 2.1.6定点整数VS定点小数⭐⭐定点数取值范围	

​![image.png](assets/net-img-202310180016635-20231113184630-tekbj6a.png)​

​![image.png](assets/net-img-202310180016636-20231113184630-gzmd6sg.png)​

## 2.2运算方法和运算电路

### 2.2.1基本运算部件

先看6   ---->6.最基本的逻辑运算⭐

#### 1.一位全加器​![image.png](assets/net-img-202310180016642-20231113184631-cmnogt6.png)​

#### 2.串行进位加法器​![image.png](assets/net-img-202310180016645-20231113184632-lll0z7d.png)​

#### 3.并行加法器

##### （串行进位的并行加法器）

​![image.png](assets/net-img-202310180016649-20231113184632-gg2niiz.png)​

​![image.png](assets/net-img-202310180016650-20231113184633-67hgwi2.png)​

##### **并行加法器的优化（并行进位的并行加法器）**

![image.png](assets/net-img-202310180016651-20231113184633-dkbo94r.png)

#### 4.带标志加法器

#### 5.ALU(算数逻辑单元)​![image.png](assets/net-img-202310180016657-20231113184634-g8wr02n.png)​

#### 6.最基本的逻辑运算⭐

​![image.png](assets/net-img-202310180016658-20231113184634-5w5nocs.png)  
​![image.png](assets/net-img-202310180016659-20231113184635-hiq52o4.png)​

​![image.png](assets/net-img-202310180016660-20231113184635-pzzv6bb.png)  
​![image.png](assets/net-img-202310180016661-20231113184635-tk93h9t.png)  
​![image.png](assets/net-img-202310180016662-20231113184636-75zrsz3.png)​

#### 7.总结

![image.png](assets/net-img-202310180016663-20231113184637-pfvxcx5.png)

### 2.2.2定点数的移位运算

​![image.png](assets/net-img-202310180016664-20231113184637-gwn6cf8.png)​

#### 1.算术移位⭐

算术移位：①移动的是数值位；②原码，反码，补码，左移右移补的不一样。

##### （1）原码的算术移位![image.png](assets/net-img-202310180016667-20231113184637-an3f4l3.png)![image.png](assets/net-img-202310180016668-20231113184638-l1yzcb7.png)

**原码算数右移，就是整体数值位右移，也相当于小数点左移，整体/2；**

**原码算数左移，就是整体数值位左移，也相当于小数点右移，整体*2。**

##### （2）反码的算术移位

![image.png](assets/net-img-202310180016669-20231113184639-5ng1i5f.png)

##### （3）补码的算术移位

![image.png](assets/net-img-202310180016670-20231113184639-cusc0af.png)
算数移位举例
![image.png](assets/net-img-202310180016671-20231113184640-9efzixd.png)
![image.png](assets/net-img-202310180016672-20231113184640-smzk259.png)

#### 2.逻辑移位

​![image.png](assets/net-img-202310180016673-20231113184640-amuegx6.png)  
  
​![image.png](assets/net-img-202310180016674-20231113184641-qspv2te.png)  
举例  
​![image.png](assets/net-img-202310180016675-20231113184641-cx6qrq7.png)​

#### 3.循环移位

  
​![image.png](assets/net-img-202310180016677-20231113184642-mzvv96q.png)​

### 总结

![image.png](assets/net-img-202310180016678-20231113184642-kbg7eac.png)

### 2.2.3定点数的加减运算

#### 补码加减运算器

##### 加法器原理

![image.png](assets/net-img-202310180016687-20231113184643-ezh09ly.png)

##### 补码加减法运算复习

​![image.png](assets/net-img-202310180016688-20231113184643-elc08df.png)​

​![image.png](assets/net-img-202310180016690-20231113184644-j45cb5y.png)​

**加法运算时，sub=0，正常计算；如果减法运算时，sub=1，减法转化为加法，加数取反+1（因为sub=1，所以输入的cin=1，在多路选择器取反之后，在这里+1）。
注意一下，计算之前用10进制算一下是否溢出；注意n进制原码及补码取值区间**

##### 无符号数的加减法

​![image.png](assets/net-img-202310180016691-20231113184644-ngasilg.png)​

**无符号整数的加减法与补码加减法一致；但是判断溢出的方式不同
注意一下,与和带符号数一样，计算之前用10进制算一下是否溢出；注意n进制无符号数的区间**

##### 标志位的生成

![image.png](assets/net-img-202310180016692-20231113184645-mr91cp9.png)

​​

### 2.2.4乘法运算

![image.png](assets/net-img-202310180016710-20231113184646-26txjkh.png)

#### 原码的乘法运算

![image.png](assets/net-img-202310180016711-20231113184646-qeksr88.png)

#### 原码的乘法运算-符号位的确定通过异或实现

![image.png](assets/net-img-202310180016712-20231113184646-kx9lc7r.png)
![image.png](assets/net-img-202310180016713-20231113184647-bv4ircq.png)

#### 原码的一位乘法

​![image.png](assets/net-img-202310180016714-20231113184648-120xlzx.png)  
​![image.png](assets/net-img-202310180016715-20231113184648-6dou2bl.png)  
​![image.png](assets/net-img-202310180016716-20231113184649-mq5r3wg.png)  
​![image.png](assets/net-img-202310180016717-20231113184649-gajhsy2.png)  
​![image.png](assets/net-img-202310180016718-20231113184650-tm2rzkx.png)	![image.png](assets/net-img-202310180016719-20231113184650-c9uehqo.png)  
补充：部分积的概念  
​![image.png](assets/net-img-202310180016720-20231113184651-e0fnm58.png)  
​![image.png](assets/net-img-202310180016721-20231113184651-aqpthyf.png)  
​![image.png](assets/net-img-202310180016722-20231113184652-6e3zxvb.png)  
​![image.png](assets/net-img-202310180016723-20231113184652-055w8lp.png)  
​![image.png](assets/net-img-202310180016724-20231113184653-a78e1q5.png)

​![](assets/net-img-202310180016727-20231113184653-1f9ectr.png)​  
​![image.png](assets/net-img-202310180016725-20231113184654-m5jtt5j.png)​

##### 手算模拟

​![image.png](assets/net-img-202310180016726-20231113184654-7wowh00.png)  
​​

#### 补码的一位乘法

![image.png](assets/net-img-202310180016728-20231113184655-zpymc1u.png)
![image.png](assets/net-img-202310180016729-20231113184655-0dhfedi.png)

##### 补码的一位乘法-手算模拟

![image.png](assets/net-img-202310180016730-20231113184656-85xx0pd.png)

#### 本节回顾

​![image.png](assets/net-img-202310180016731-20231113184656-dzlm0fu.png)​

## 除法运算

​![image.png](assets/net-img-202310180016732-20231113184657-x2oxkg7.png)​

### 十进制除法（手算）

![image.png](assets/net-img-202310180016733-20231113184657-jrdz4l4.png)
![image.png](assets/net-img-202310180016734-20231113184658-zdf84kq.png)

### 原码+补码除法

![image.png](assets/net-img-202310180016735-20231113184658-bzv04ev.png)

#### 原码除法：恢复余数法

​![image.png](assets/net-img-202310180016736-20231113184659-nzmkloe.png)  
​![image.png](assets/net-img-202310180016737-20231113184700-tgqfscs.png)  
​![image.png](assets/net-img-202310180016738-20231113184700-wnaezli.png)  
​![image.png](assets/net-img-202310180016739-20231113184701-s398qjt.png)  
下一位  
​![image.png](assets/net-img-202310180016740-20231113184702-gwmpfw1.png)  
​![image.png](assets/net-img-202310180016741-20231113184702-et033x6.png)  
下一位  
​![image.png](assets/net-img-202310180016742-20231113184703-ccopa3w.png)  
​![image.png](assets/net-img-202310180016743-20231113184703-68yc87z.png)  
**下一位，先是1，但是是错的，恢复并逻辑左移，**   
​![image.png](assets/net-img-202310180016744-20231113184704-1lgid0k.png)  
​![image.png](assets/net-img-202310180016745-20231113184705-r5mhiwy.png)  
**逻辑左移进入下一位**  
​![image.png](assets/net-img-202310180016746-20231113184705-3210dts.png)  
​![image.png](assets/net-img-202310180016747-20231113184706-kw7cikf.png)  
计算结束  
​![image.png](assets/net-img-202310180016748-20231113184706-sihbu4b.png)  
**最后处理符号**  
​![image.png](assets/net-img-202310180016749-20231113184707-1ie27lm.png)​

**最后得到的余数还要*2的负n才是真正的余数**

#### 恢复余数法-手算

![image.png](assets/net-img-202310180016750-20231113184707-41y4lph.png)
![image.png](assets/net-img-202310180016751-20231113184708-9qiqj27.png)

#### 原码除法-加减交替法/不恢复余数法

​![image.png](assets/net-img-202310180016752-20231113184708-524bcra.png)  
上面的余数a为负的地方直接商0了吧？  
**左移就相当于向前一项借位**

​![image.png](assets/net-img-202310180016753-20231113184709-w2baef7.png)  
​![image.png](assets/net-img-202310180016754-20231113184710-1cxfbzh.png)  
  
**被除数一定要大于除数（符号位为1），否则上面第一步就停止，因为表示不了（定点小数，表示不了1）**

**N+2的情况是：最终余数为负，需要加一次（除数吧）恢复余数**

#### 定点数补码除法

​![image.png](assets/net-img-202310180016755-20231113184710-ks5rw1n.png)  

### 总结

​![image.png](assets/net-img-202310180016756-20231113184711-ydos0wn.png)  
  
**N+2的情况是：最终余数为负，需要加一次（除数吧）恢复余数**

### 2.2.5 C语言中的整数类型及强制类型转换

#### 2．不同字长整数之间的转换​![image.png](assets/net-img-202310180016761-20231113184711-07owor2.png)​

### 2.2.6数据的存储与排列

#### 1．数据的“大端方式”和“小端方式”存储

​![image.png](assets/net-img-202310180016764-20231113184712-5gpw8mr.png)​

#### 2．数据按“边界对齐”方式存储

我把**按字节寻址**与**按字寻址**搞反了；  
注意区分**字节（B）** 和**bit（比特）** ；  
**注意：区分编址和寻址方式**

​![image.png](assets/net-img-202310180016767-20231113184712-u701g53.png)![image.png](assets/net-img-202310180016768-20231113184713-i5bwa6c.png)![image.png](assets/net-img-202310180016769-20231113184713-njj0121.png)  
​![image.png](assets/net-img-202310180016770-20231113184714-iu406go.png)  
​![image.png](assets/net-img-202310180016771-20231113184714-h77rinf.png)  
​![image.png](assets/net-img-202310180016772-20231113184715-4l24np1.png)​

## 浮点数的表示和运算

![image.png](assets/net-img-202310180016773-20231113184715-dy7khjo.png)

### 浮点数的表示

#### 定点数的局限性

不能一直通过增加长度来完成（2B-->4B-->8B.....）  
​![image.png](assets/net-img-202310180016774-20231113184716-al5fvtl.png)​

#### 用科学计数法理解浮点数

​![image.png](assets/net-img-202310180016775-20231113184716-gempdim.png)​

#### 浮点数的表示⭐

​![image.png](assets/net-img-202310180016776-20231113184717-41rqb5b.png)​

* **1.定点数小数点的位置固定不变，浮点数小数点的位置是会发生变化的；**

  * 例如上方浮点数2*0.xxxx的话可以看做小数点右移一位/数字左移一位
* 2.**阶码的底也可以是2的i次方**

例题

​![image.png](assets/net-img-202310180016777-20231113184717-ghwo6ur.png)​

​![image.png](assets/net-img-202310180016778-20231113184718-9x6t46z.png)​

上题，绿色/蓝色头部表示的符号；  
1个B=8个bit而上面b有九位；这样写尾数最后直接溢出，精度丢失，可以修改为： ** 001 01001 ** → 这叫左规，下面有，**这个操作就是，阶码/2的同时（就是减一），尾数*2（整体数值左移一位），**

#### 浮点数尾数的规格化（左规/右规）

**左归**  
​![image.png](assets/net-img-202310180016779-20231113184718-o5yzh3i.png)​

**在科学计数法中，尾数的最高位必须是有效值----&gt;推论到浮点数也是如此尾数的最高位数值必须是一个有效值；小数点右移一位=算数左移一位---&gt;这称为左规**

##### 总结

​![image.png](assets/net-img-202310180016780-20231113184719-lj00sx3.png)  
  
**当浮点数尾数溢出（双符号位出现01/10时），算数右规（这是缩小了），阶码+1（所以这里增大一下）**

#### 规格化浮点数的特点（原码/补码的规格化）

![image.png](assets/net-img-202310180016781-20231113184720-e3ekj3y.png)

> 注意：说的都是最高“数值位”

​![image.png](assets/net-img-202310180016782-20231113184720-ysev686.png)  
  
  
**注意：1.0001100左移三位之后1.1100000，往前移动的数并不会补到符号位**

**下面的注是指的负数的补码；正数的补码与原码一样都是补0
大纲里删除了**  
​![image.png](assets/net-img-202310180016783-20231113184721-i5wvhea.png)​

#### 总结

![image.png](assets/net-img-202310180016784-20231113184721-kavsh74.png)

### 浮点数标准IEEE745

​![image.png](assets/net-img-202310180016785-20231113184722-fsibbv4.png)​  
**注意：移码只能表示整数**

#### 移码的正式计算方法

​![image.png](assets/net-img-202310180016786-20231113184722-bl8r5yl.png)  
  
**求移码必须先知道偏置值，偏置值=2的（n-1）次方；此时移码的简便算法就是补码的符号位取反**

**而移码的偏置值可以取其他值，例如下面，这里移码作为阶码，偏置值=2的（n-1）次方-1；
计算真值=-128，而移码只有127 ；（下面我不懂）而这里移码的位数只有8bit，所有的加减运算背后都默认进行mod2的8次方运算可以给他加上一个2的8次方，整体结果是不会变的**

​![image.png](assets/net-img-202310180016787-20231113184723-mlgv3jp.png)  
​![image.png](assets/net-img-202310180016788-20231113184723-z22cgcs.png)  
​![image.png](assets/net-img-202310180016789-20231113184723-coqwd6r.png)  
​![image.png](assets/net-img-202310180016790-20231113184724-ia0ntwp.png)  
​![image.png](assets/net-img-202310180016791-20231113184724-yxcrox6.png)  
  
**前面的数符表示的是符号，所以后面用原码表示的尾数部分不需要符号位1/0，而且因为规格化的标准，尾数部分只能是正数时0.1，负数是1.1，符号位不用自己表示，1也省略了，后面只剩下M了 ，完整是ms .1M；而又因为偏置值使得真值计算为   ：（-1）的s次方**​***1.M***​**2的（E-127）次方---&gt;原本是E-128,这里变相的乘了一个2，这个2的作用是使ms .1M变成1.M 前面ms是个符号位直接就（-1）的s次方计算了《---推测哈**

#### 十进制准化为IEEE754例题

​![image.png](assets/net-img-202310180016792-20231113184725-do8azz0.png)

首先，将十进制数转化为二进制原码，将ms.1M写成1.M看看需要移动多少，则阶码部分移动相反的数量

**注意：符号位是ms这里，1.M中的1就是省略的**

#### 十六进制IEEE754转化为十进制数

​![image.png](assets/net-img-202310180016793-20231113184725-t62meoa.png)

**这里不要想那麽多，直接±1.M*2的移码-偏置值**

‍

#### IEEE754可以表示的最小绝对值，最大绝对值？

![image.png](assets/net-img-202310180016794-20231113184726-1h2dlmk.png)

#### 若要表示的数绝对值还要更小，怎么办？借助之前留下的阶码真值数-128 -127

![image.png](assets/net-img-202310180016795-20231113184727-aa5tc6l.png)
![image.png](assets/net-img-202310180016796-20231113184727-yjtxg0h.png)

#### 知识点回顾

![image.png](assets/net-img-202310180016797-20231113184728-w741gxw.png)

### 浮点数的运算

![image.png](assets/net-img-202310180016798-20231113184728-qpmkrdc.png)

#### 浮点数的加减运算

![image.png](assets/net-img-202310180016799-20231113184729-9efvcp1.png)
![image.png](assets/net-img-202310180016800-20231113184729-gi2mb3t.png)
![image.png](assets/net-img-202310180016801-20231113184730-z6dkcsr.png)
![image.png](assets/net-img-202310180016802-20231113184731-2j2ln7p.png)

#### 强制类型转化

![image.png](assets/net-img-202310180016803-20231113184731-ugs5pkj.png)

#### 本节回顾![image.png](assets/net-img-202310180016804-20231113184732-w8iqcif.png)

# 第三章 存储系统

​![image.png](assets/net-img-202310180016805-20231113184732-y0uyw4c.png)​

## 存储系统的基本概念

​![image.png](assets/net-img-202310180016806-20231113184733-58jopb7.png)​

### 存储器的层次化结构

​![image.png](assets/net-img-202310180016807-20231113184733-sae7sis.png)​

主存与辅存之间的数据调度只对**应用**程序员透明

### 存储器的分类⭐⭐

#### 按层次分类

​![image.png](assets/net-img-202310180016808-20231113184734-486pf10.png)​

#### 存储介质

​![image.png](assets/net-img-202310180016809-20231113184734-tq9k7wd.png)​

#### 存取方式

​![image.png](assets/net-img-202310180016810-20231113184735-n7cysqv.png)​

#### 信息的可更改性

​![image.png](assets/net-img-202310180016811-20231113184735-0j7qpoy.png)​

#### 信息的可保存性

​![image.png](assets/net-img-202310180016812-20231113184736-q6pjc01.png)​

### 存储器的性能指标⭐⭐

​![image.png](assets/net-img-202310180016813-20231113184736-hjw5dp8.png)​

### 本节回顾

​![image.png](assets/net-img-202310180016814-20231113184737-urgykbh.png)​

## 主存储器的基本组成

​![image.png](assets/net-img-202310180016815-20231113184737-mu5fxyx.png)​

### 基本的半导体元件及其原理

​![image.png](assets/net-img-202310180016816-20231113184738-2ge6mmw.png)​

**存储元的读出操作：电容这里有电荷显示为1，当mos管接通一个5v的高电平后，mos接通，右侧端点显示有电流显示为1
存储元的写入操作：右侧端点接通一个5v的高电平显示为1，当mos管接通一个5v的高电平后，mos接通，电容这里有电荷移动存储了一些电荷显示为1，断电之后，他也跑不出去**

**两个半导体元件：mos管和电容**  
**mos管达到阈值就导电，否则就是个绝缘体。
注意：接地是0v**

### 存储芯片的基本原理

​![image.png](assets/net-img-202310180016817-20231113184738-qpvaqqg.png)​

这里的数据总线是主存储器**内部**的吧

​![image.png](assets/net-img-202310180016818-20231113184739-pqsp2qx.png)​

**控制电路的作用：**   
**1.等待MAR中的电信号稳定之后，打开译码器开关，翻译MAR地址，给出数据信号；
2.数据输出的时候，只有输出的电信号稳定之后。控制MDR给数据总线送出数据**

  
​![image.png](assets/net-img-202310180016819-20231113184739-ojqlhnr.png)

**驱动器：一般放在译码器之后，放大电流，保证电流稳定；保证译码器的电信号是稳定可靠的**

**片选线：这块芯片是否可用，按照右图，需要用到的存储芯片置为低电平，其余高电平（注意：低电平有效）**

**引脚的数量对应着地址线，数据线，片选线，读/写控制线，注意，读/写控制线可能一条，也可能两条
片选线的作用：一个内存条上面有多块存储芯片，当只使用某一个的时候，给他s低电平，其余的高电平**

​![image.png](assets/net-img-202310180016820-20231113184740-flf5e19.png)

左边这三个规格的存储芯片的引脚数量，  
13+8+1+2  
13+1+1+2  
16+16+1+2  
因为这里确定的读写控制线有两条，  
在别的题目中可能只有1条，所以要注意

### 如何实现不同的寻址方式

​![image.png](assets/net-img-202310180016821-20231113184740-5qo7u0e.png)​

**注意：** 左面是**按字节编址**，**总容量**为**1KB(存储单元)** ，所以需要**10根地址线**（**2****^10^** **=1K**），**一共10位地址**  
如果是**按字寻址**，  
只要算是左移两位就能找到其起始字节的字节地址，例如找**字为1**的**起始字节地址**，左移两位变成100（4），4就是其字节的地址

### 本节回顾

![image.png](assets/net-img-202310180016822-20231113184741-qnjx2pt.png)

## SRAM和DRAM(两种特定存储芯片)

​![image.png](assets/net-img-202310180016823-20231113184741-soye0sw.png)

**RAM**  
​![image.png](assets/net-img-202310180016824-20231113184742-kfy62g6.png)​

### 存储单元不同造成的特性差异

#### DRAM芯片

**注意：如果DRAM使用地址复用技术，则地址线减半，片选线没了，但多了两条（行通选，列通选；片选线被行通选代替）** 

​![image.png](assets/net-img-202310180016825-20231113184742-n1jcgpc.png)​

#### 栅极电容 vs 双稳态触发器

##### 栅极电路

​![image.png](assets/net-img-202310180016826-20231113184743-ca1qpoj.png)​

​![image.png](assets/net-img-202310180016828-20231113184743-zm0hhhy.png)​

##### 双稳态触发器

​![image.png](assets/net-img-202310180016829-20231113184744-zib59zz.png)​

**双稳态触发器如何读取？
读取操作：给字选择线接通5v高电平之后，看那边输出0，BL为0时，A点低-----0
BLX为0时，B点低----1
写入更容易了，给两条绿线接不同电平**  

##### 对比⭐

​![image.png](assets/net-img-202310180016830-20231113184744-tnwaxyi.png)

  
​![image.png](assets/net-img-202310180016831-20231113184745-2lsuo8d.png)

​![image.png](assets/net-img-202310180016832-20231113184746-lp5dnbv.png)​

* **为什么DRAM需要刷新？因为是电容，会自己放电**

  * **DRAM使用了地址线复用技术之后，行列地址，分两次送，只需要n/2条地址线（之前需要n条），从而引脚也更少了**

##### 刷新的概念

​![image.png](assets/net-img-202310180016833-20231113184746-52hk766.png)​

### DRAM的刷新⭐⭐

**注意：如果DRAM使用地址复用技术，则地址线减半，片选线没了，但多了两条（行通选，列通选；片选线被行通选代替）** 

​![image.png](assets/net-img-202310180016834-20231113184747-vs3czek.png)​

**注意：地址线的数目没有变化，内部选通线的数目变化**

​![image.png](assets/net-img-202310180016835-20231113184747-whqjx80.png)​

​![image.png](assets/net-img-202310180016836-20231113184748-s3h2xp0.png)​

### DRAM的地址线复用技术

**注意：如果DRAM使用地址复用技术，则地址线减半，片选线没了，但多了两条（行通选，列通选；片选线被行通选代替）** 

**什么叫送行列地址？**   
​![image.png](assets/net-img-202310180016837-20231113184748-kqwaqqk.png)​

​![image.png](assets/net-img-202310180016838-20231113184749-q8eo68u.png)​

### 本节回顾

![image.png](assets/net-img-202310180016839-20231113184749-z36z6t9.png)

## 只读存储器ROM

​![image.png](assets/net-img-202310180016840-20231113184750-klcwukr.png)​

### 了解各种ROM

![image.png](assets/net-img-202310180016841-20231113184750-hx29aj5.png)

### 计算机内的重要ROM

​![image.png](assets/net-img-202310180016842-20231113184751-ugju78t.png)  
​![image.png](assets/net-img-202310180016843-20231113184752-3rdbfcf.png)  

### 本节回顾

![image.png](assets/net-img-202310180016844-20231113184752-hmlv114.png)

## 双端口RAM和多模块存储器⭐

​![image.png](assets/net-img-202310180016845-20231113184753-yivr8zr.png)  
  
​![image.png](assets/net-img-202310180016846-20231113184753-ti9mvdj.png)​

### 双端口RAM

![image.png](assets/net-img-202310180016847-20231113184754-q7w13ts.png)

### 多体并行存储器⭐

​![image.png](assets/net-img-1692870299190-aa8a529e-c7ee-4d7e-b6ad-70a2ad7e3670-20231017224844-878o7ol.png)  
​![image.png](assets/net-img-1692870468924-3c8c9b0e-2fe1-4b16-94d4-cad751f544ba-20231017224844-h751w3l.png)  
**用5个表示主存地址**  
​![image.png](assets/net-img-1692870614763-632c40c5-bd69-4c73-94c3-c2a5344fbe16-20231017224844-xik712k.png)​  
一个竖着编，一个横着编  
​![image.png](assets/net-img-1692870951465-d6b26e2e-d03a-436d-a44f-eaac56f975e0-20231017224844-ct1jlb4.png)

  
​![image.png](assets/net-img-1692871024982-a2440fb9-bf9b-42cb-a019-72bbb094d1b2-20231017224844-1pzjovs.png)![image.png](assets/net-img-1692871090067-351b51a5-cbe6-430f-a047-7ad32758fe4d-20231017224844-z717hk2.png)​

![image.png](assets/net-img-1692877102441-573854fe-159e-469e-a2d5-a315166b16a5-20231017224844-gjnynl7.png)
![image.png](assets/net-img-1692877545503-26af1293-ebda-4d78-9cfe-32a087aa9492-20231017224844-ryinkkm.png)
![image.png](assets/net-img-1692877695643-52893de2-1b37-4111-a640-26d080ac072e-20231017224844-ivw0vqi.png)

### 本节回顾

![image.png](assets/net-img-1692877713227-c9977d90-f23c-4661-861d-c86b8f78644f-20231017224845-rtsx293.png)
![image.png](assets/net-img-1692878027506-e856bd9e-7861-4d40-a57f-872db9665d79-20231017224845-lnwb7uj.png)

## 主存储器与CPU的连接⭐⭐

​![image.png](assets/net-img-1692878098324-8e977471-ff14-46f6-861e-b9e4768940a9-20231017224845-r2ms23k.png)​

### 单块存储芯片与CPU的连接

​![image.png](assets/net-img-1692878502399-a27be9e9-7072-4975-acb8-e61fa5b8f30d-20231017224845-kd1yi52.png)​

* **①现在电脑的存储字长都是64bit，而上面图示为8bit，表示一次能处理的数据**
* **②现代计算机MAR与MDR都集成在CPU，而不是内存中**
* **片选线：这块芯片是否可用，**

### 多块存储芯片与CPU的连接

​![image.png](assets/net-img-1692879131727-b91763bb-4ae4-4c8c-9c88-cc729e8e8c60-20231017224845-1npm8t7.png)​

​![image.png](assets/net-img-1692879387481-b042c3f8-d988-468c-90f3-01a26b5c8ea7-20231017224845-ri6hgad.png)​

#### 增加主存的存储字长---位扩展

* **数据总线宽度＞存储芯片字长→方法：**​**添加存储芯片**

​![image.png](assets/net-img-1692879676961-9a2f4099-b34c-424c-bf2b-37f2b120b2ce-20231017224845-im5kvre.png)​

​![image.png](assets/net-img-1692879871243-3892ab8e-9f21-4638-bd3c-916765144952-20231017224845-2x9vw6w.png)​

**按照上面的方法，一共8个内存条，此时存储器的存储字长为8bit与CPU一致了**

​![image.png](assets/net-img-1692879933624-ab5b6c6f-ca79-4c9d-8b9f-a89d9ff2a5a9-20231017224845-7et1t60.png)​

#### 增加容量拓展---字扩展

##### 线选法

**这两个内存条都是存储字长都是8bit了，但是此时的地址位一共有13位，但是CPU上有16位，无法发挥它的寻址能力；按照之前位扩展的方式连接，要是两边cs都为1的话，他两个同时工作，都输出/写入8bit的数据冲突了，所以必须为10/01才可以**

​​![image](assets/image-20231201220209-yfdwqwx.png)​​

​![image.png](assets/net-img-1692880302556-851c2b4a-7260-4415-ad2e-8ed0288e7bf6-20231017224845-pmz39e0.png)​

##### 译码片选法

​![image.png](assets/net-img-1692881307828-112fc5c0-7f49-4e80-a49b-6e068fc99e0c-20231017224846-z2q9g6h.png)​

​![image.png](assets/net-img-1692881440000-2793d63f-0e0b-4f3b-811d-f0b6f071e248-20231017224846-mq72sgj.png)![image.png](assets/net-img-1692881501030-45c6ebfd-e3d2-403d-ade4-36d1c3e8ea74-20231017224846-xrgvsd7.png)![image.png](assets/net-img-1692881577381-bcb562f6-0730-4409-9dd3-75cd97e7a6bd-20231017224846-eh7usnz.png)​

​![image.png](assets/net-img-1692881891791-fdb5d969-dddb-422a-89a6-648e078c05ee-20231017224846-d9y46ba.png)​

​![image.png](assets/net-img-1692882123230-35314c02-951f-4175-8808-e9b047351936-20231017224846-zjzdre6.png)​

##### 线选法和译码片选法比较

​![image.png](assets/net-img-1692882233488-9b09b5d5-6b86-480a-92a0-203c44ca8d44-20231017224846-qb5h28o.png)​

#### 字位同时扩展

​![image.png](assets/net-img-1692882615980-56842d14-8994-47be-b20a-69e7ecc549a5-20231017224846-3xff5n4.png)​

#### 本节回顾

​![image.png](assets/net-img-1692882668112-24518a5b-4833-4a6f-a01b-3ad1f389faf9-20231017224846-s39wc5c.png)​

### 关于译码器知识的补充

* 左边的译码器，哪个生效显示1，正好链接下面的cs，正好是高电平有效；  
  右边的译码器，哪个生效显示0，正好链接下面的**cs（上面带杠）** ，正好是低电平有效；  
  使能端：使译码器能够工作

​![image.png](assets/net-img-1692882793096-367b54be-1eb3-497f-8f0a-ce5850675a56-20231017224846-whn2zse.png)​

**使能端开启**  
​![image.png](assets/net-img-1692882867758-79de86bc-7dcd-4403-a5d1-09f94e7ba5ae-20231017224846-1eaom4z.png)​

**只有使能端为**​ ** 1 0 0 ** **时，译码器才生效；无效条件下译码器显示全1**

**使能端关闭**  
​![image.png](assets/net-img-1692882983978-1cd35ae2-9d0b-49eb-a9ed-9ec66e47d28a-20231017224846-cmpur6n.png)​

  
​![image.png](assets/net-img-1692883286316-845af3ae-ca9e-449c-a71b-088d7c49ff07-20231017224846-kpbw7ti.png)

* **cpu先通过地址信号送出地址信号，和上面三位（CBA这三个），刚送出不稳定，待稳定后发出主存请求信号（MREQ带杠的）使译码器生效**

​![1699603913582](assets/1699603913582-20231110161205-4r6z1o9.png)​

* **竖线1时，cpu发出地址信号，到竖线2时稳定了，然后cpu发出地址请求信号，cs（杠）连通，竖线3数据可以传出了，传了一会在竖线4时，cpu撤销地址请求信号，经过一段时间数据传出给cpu，在cpu确定接收到数据之后才会撤销地址信号即竖线5**

* **注意：白色的部分表示传的01信号，地址信号可0可1，所以那样画，cs低电平有效，数据输出信号可0可1；灰色部分表示没有数据输出**

## 外存储器

​![image.png](assets/net-img-1692944691265-f807c835-e304-428c-b4c7-3c3657f42101-20231017224846-0lk7rs7.png)​

#### 磁盘存储器

**磁表面存储器：1.每次读/写都是1bit  2.不能同时读写   3.很容易收到强磁场的影响**  
**机械硬盘**就是**磁表面存储器**，还有磁带，**机械硬盘应该就是磁盘存储器**  
​![image.png](assets/net-img-1692945101364-ef27956c-5892-490e-a94a-d056b90e3cb5-20231017224847-nywhlfh.png)​

##### 1.磁盘设备的组成

​![image.png](assets/net-img-1692945769194-b2735bd6-d89c-4d8c-a943-16dd60d3df60-20231017224847-kurpd6g.png)

**磁盘存储器是由磁盘驱动器，磁盘控制器和盘片组成**  
​![image.png](assets/net-img-1692945458869-f80629f5-59cc-4764-9fa4-7c5c5de0263e-20231017224847-dg43k14.png)  
​![image.png](assets/net-img-1692945810864-0885408f-a956-4810-83df-33238b695fec-20231017224847-1vb93vn.png)​

##### 2.磁盘的性能指标⭐

​![image.png](assets/net-img-1692946366792-ed7ff4f2-c75c-4c5b-bd58-db6c074056ae-20231017224847-cx3n2db.png)  
​![image.png](assets/net-img-1692947472176-41d03edd-c9a6-41fc-87bd-d75bd3f4cbb6-20231017224847-atjk2q9.png)  
​​![image](assets/image-20231111144516-2h4dprh.png)​​

##### 3.磁盘地址

![image.png](assets/net-img-1692947780240-a27997f8-7e61-408c-ac22-8470d2e7b0f5-20231017224847-5347rot.png)

##### 4.磁盘的工作过程

​![image.png](assets/net-img-1692948033908-87b5ff6f-bfdd-4c24-9ceb-4d1d4b21636d-20231017224847-dwc3ynp.png)  

‍

  
**因为每次只能读/写1bit的限制，所以需要并-串变换电路+串-并变换电路**  
​![image.png](assets/net-img-1692948107341-0ee7de26-891c-41a1-b484-f7c93a808f6d-20231017224847-y9rk77i.png)​

#### 磁盘阵列

​![image.png](assets/net-img-1692948422669-e40268c5-ed71-4c78-a9a6-892b56e8c97b-20231017224848-7elpz4u.png)  
​![image.png](assets/net-img-1692948460065-6afc5f5a-e90f-409e-b510-e55e0fd0b49a-20231017224848-j1grjkt.png)  
  
**RAID0的局限性：磁盘扇区损坏数据就没了；磁盘数据发生跳变（0变1，1变0）也校验不出来**  
  
​![image.png](assets/net-img-1692948779430-a3b32edc-782b-4937-acf5-40bef7df3952-20231017224848-4s6kul2.png)![image.png](assets/net-img-1692948785183-d8638db9-8456-4ba6-bcc9-788e4c042083-20231017224848-45p9md9.png)  
​![image.png](assets/net-img-1692948936652-73bef616-0108-4a84-b93d-32c476c9346c-20231017224848-kbgffln.png)![image.png](assets/net-img-1692948962237-f75c79c4-27df-4ec8-a1ee-c3f8b98a2ad4-20231017224848-ojkkera.png)  
​![image.png](assets/net-img-1692949067656-df53ac49-2c71-41a5-a023-627711e343a1-20231017224848-be8auv8.png)​

#### 本节回顾

​![image.png](assets/net-img-1692949121154-e330ce26-6a3b-4ebc-ab53-90ee1ccb01d0-20231017224848-mmb135o.png)​

### 固态硬盘SSD

​![image.png](assets/net-img-1692949308749-0ea49dae-e346-4c38-a6df-f9efe4d3b12c-20231017224848-swvx3rc.png)

注意：随机写很慢

#### 固态硬盘的结构

​![image.png](assets/net-img-1692949409308-ce766b41-51a8-4d29-9c4a-1c6b79ca3c89-20231017224848-p0iwrjl.png)

​![image.png](assets/net-img-1692949783107-50f7b777-70e2-4008-8358-104dc92c0a58-20231017224849-x4ulpka.png)​

  
**固态硬盘中的块相当于机械硬盘中的磁道**  
**固态硬盘中的页相当于机械硬盘中的扇区**

​![image.png](assets/net-img-1692950377406-b37692e6-7a89-48f9-bd4f-10ddf216105d-20231017224849-ntz23wk.png)  
  
**将逻辑块号映射到不同的物理地址**  
  
​![image.png](assets/net-img-1692951818647-f1d45fe4-c939-4040-8111-70fb30bb1025-20231017224849-dghfym1.png)​

## Cache⭐⭐

### Cache-基本原理和基本概念

​![image.png](assets/net-img-1692952003758-1d490afe-e2b0-453c-bbcf-3d8849d8b28f-20231017224849-6sovkgq.png)​

​![image.png](assets/net-img-1692952396474-f6f8ff3f-8f42-4546-9def-7bc8ef44ad0b-20231017224849-488uejr.png)​

#### 局部性原理⭐

​![image.png](assets/net-img-1692952825814-426f106d-0915-4f19-9ed5-17060d948d28-20231017224849-azvw367.png)​

​![image.png](assets/net-img-1692953061667-3809f1f4-b542-4035-a4b9-defc4811a388-20231017224849-7eqer46.png)​

​![image.png](assets/net-img-1692953417374-ef916bce-ef50-4698-869d-0b26e64123f0-20231017224849-vk5zyfx.png)​

​![image.png](assets/net-img-1692953564988-24bd41fb-93dc-4de4-bbaa-ecac54fc7040-20231017224849-t0xwt26.png)​

​![image.png](assets/net-img-1692953713062-e5ca2e1f-b384-4671-a5c2-d03bca3f82d0-20231017224849-kjo2fvr.png)​

​![image.png](assets/net-img-1692953856865-9d0bc86b-bfa8-4293-96d1-79cd57f1a054-20231017224850-j4cmgsy.png)​

#### 本节回顾

​![image.png](assets/net-img-1692953882743-0f420f3d-519a-4e40-97bb-61df7dd3e08e-20231017224850-hy1xc1e.png)​

### ⭐Cache-主存映射方式--3种映射方式

* **如何区分Cache与主存的数据块对应关系？--Cache和主存的映射方式**​​

​![image.png](assets/net-img-1693032180373-80ed6e77-fa55-4aba-a2a5-becb8487eefa-20231017224850-qp5ehsj.png)​

#### 全相联映射

* **256MB=2**​^**28**^​**B**
* **按字节编址：每个字节对应一个地址**
* **所以，地址共有28位；前22位表示块号，后6位表示块内地址**

​![image.png](assets/net-img-1693033158948-d0d78a99-7b2d-4fcd-8248-2a98df99153b-20231017224850-xtlq4iv.png)​

* **设置标志位是为了区分**​**0号块与其它没存东西的块**

​![](assets/net-img-1693045196828-9ba9ac09-1b94-453c-be48-61387207c29b-20231017224850-e9o0s5p.png)​

##### 全相联映射-cpu访存

​![](assets/net-img-1693045196967-2c74bcbe-8be4-4f58-bea5-a4129a43469f-20231017224850-o9teldq.png)  

#### 直接映射

​![](assets/net-img-1693045196912-f3a27948-24ec-4d3b-b64c-9435ec237b17-20231017224850-l9udyrl.png)​

##### 直接映射-优化

* **主存块号对Cache块号取余=cahe中的地址**

​![](assets/net-img-1693045197152-dbb50d6b-04fa-4a95-a83a-a60ab287e8f5-20231017224851-dotwehw.png)​

​![](assets/net-img-1693045196874-177d78ac-a20e-4e97-870e-33f6d2091c2f-20231017224851-ud35lo5.png)​

​![](assets/net-img-1693045198932-82aaa4bf-e822-4822-b11c-39ca92a342f3-20231017224851-5d6wub5.png)​

#### 组相联映射（可放到特定分组）

​![](assets/net-img-1693045199198-58c53cf5-f1ed-46c2-bdae-a73f567485c5-20231017224851-ksjd67n.png)​

​![](assets/net-img-1693045199341-4604c81d-868b-4ba0-8624-3177ceaa1f37-20231017224851-ovtkuvc.png)​

#### 本节回顾

​![](assets/net-img-1693045199280-cd981d76-836c-4917-a466-099282eac144-20231017224851-uvjr8cm.png)​

### Cache的替换算法

* **Cache很小，主存很大，如果Cache满了怎么办？ --替换算法**

  * **直接映射不需要考虑替换算法，因为他会直接替换**

​![](assets/net-img-1693045200754-12c31d15-90dd-4833-9caf-a7134bb9a2e4-20231017224851-jeipufi.png)​

​![](assets/net-img-1693045200972-39450dfb-1a41-4bd8-94e4-9c5232675ba7-20231017224851-rbta6uk.png)​

#### 随机算法

​![image.png](assets/net-img-1693203691227-7afc9025-91a5-4564-8ee5-0a8983354495-20231017224852-q8c9nn5.png)​

#### 先进先出算法

​![image.png](assets/net-img-1693204002134-cc6fbe31-452f-40fd-a806-cf6a74c8884d-20231017224852-b0g6819.png)​

#### 近期最少使用

​![image.png](assets/net-img-1693204825135-72818884-d15d-4b4c-a908-89bf0a5e95fa-20231017224852-0cwnw6r.png)​

* **注意：要是手算的话，可以在访问主存块那一行，从你即将要访问的那一个向左走，最后一个遇到的就是要替换的**

* **为什么cache块的总数=2**​**^n^**​ **，计算器只需要n**​**位** **？例如本题4=2**​**^2^**​ **，需要2位计数器0~3正好四位**

​![image.png](assets/net-img-1693205151406-1be717ff-b703-47ed-bee8-11eb76d9f01a-20231017224852-6lo5qf2.png)​

#### 最不经常使用

​![image.png](assets/net-img-1693206009202-43c3a043-b79b-4bd7-9acf-8918bb0e7aac-20231017224852-rvylu8w.png)​

​![image.png](assets/net-img-1693206179793-7a0bf31b-f125-4545-b489-d8caed9832bc-20231017224852-gtue3bj.png)​

#### 本章回顾

​![image.png](assets/net-img-1693206219060-49386dc1-5eac-4160-9bff-67c3870300c7-20231017224852-4zdfk8u.png)​

### Cache的写策略

* **CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性？ --Cache写策略**​​

​![image.png](assets/net-img-1693206511303-18401b11-d6d6-4f06-b961-03d8f228c22b-20231017224852-fkvcpp7.png)​

* **写命中与写不命中是什么意思？**

  * **写明中就是cpu要修改的那一块正好被cache从主存中放到cache内，**
  * **写不明中就是cpu要修改的那一块没有被cache从主存中放到cache内，**

#### 写命中-写回法

​![image.png](assets/net-img-1693206825124-253ff068-f255-4982-a4ac-7fc817e400d9-20231017224853-wuquhgi.png)

#### 写命中-全写法

​![image.png](assets/net-img-1693206923934-e62211dc-a28d-42be-ad22-e4cfaae6e859-20231017224853-pic058p.png)​

​![image.png](assets/net-img-1693206990799-b5a2ad20-7b3e-4817-be8a-0ec62d841c64-20231017224853-ipxvap0.png)​

​![image.png](assets/net-img-1693207010697-4c6bdb5c-d68c-49b0-9d68-10d38cc061a1-20231017224853-5zjbmsr.png)​

​![image.png](assets/net-img-1693207062896-94886966-9bb9-40aa-a9c7-5953a6e0d873-20231017224853-9bme1nu.png)​

#### 写不命中-写分配法

​![image.png](assets/net-img-1693208754220-1ae96c5b-9c63-40af-a7bd-98025fdb1389-20231017224853-9rw9s79.png)​

​![image.png](assets/net-img-1693208767222-f9eb94db-015b-4666-a608-14aa3448f4b9-20231017224853-cqk6tan.png)​

​![image.png](assets/net-img-1693208892262-94d52f8b-8c33-4fa9-88ec-2676d278b4b7-20231017224853-1n6jwps.png)​

#### 写不命中-非写分配法

​![image.png](assets/net-img-1693208982172-871dd1f6-f73f-4685-8dcb-b79832e28b12-20231017224853-awzq9mn.png)

#### 多级Cache

​![image.png](assets/net-img-1693209070446-22990112-7cf9-47e1-be60-489788143fe1-20231017224854-oy3ywbt.png)​

#### 本节回顾

​![image.png](assets/net-img-1693209132959-4e663ee9-a1e9-4606-97b4-4258821c62ba-20231017224854-rxjb8ti.png)​

### 页式存储器

​![image.png](assets/net-img-1693209511359-f88a58be-aeed-48ca-9c0f-d57dfb2b3f6d-20231017224854-ky9z892.png)![image](assets/image-20231113203735-52gmvz1.png)​

​![image.png](assets/net-img-1693209742428-488d624e-97ed-4e74-8ae8-de4e7d365ed1-20231017224854-ipy7opt.png)​

#### 虚地址 VS 实地址

* 1.在**某程序**中的两个未知数x，y（存到两个存储单元中）；
* 2.我们执行一个左上角的取数指令：000001**取数**操作码，**00**1000000011是**变量x的逻辑地址**；因为分为4页，所以使用了前两位；
* 3.可以看到**x**在 **#0第1页，实际的2号主存号；y**在 **#3第4页，实际上的第4095号主存号；**
* 4.右下角是实际地址，由**逻辑页号+页内地址**→**主存块号+页内地址；即（逻辑地址转化为物理地址）**

​![image.png](assets/net-img-1693210521813-9de66ee5-8847-444d-811f-dc65952f8e31-20231017224854-28p2l6b.png)​

* **页表存储在**​**主存****里，**​**cpu查询页表就需要一次访存操作**

​![image.png](assets/net-img-1693210698855-0d11efda-c104-4cac-b884-84a505eb1efb-20231017224854-x817mrc.png)​

#### 地址变换过程

​![image.png](assets/net-img-1693211177988-7af66bce-08a6-485a-9d78-541525616646-20231017224855-5ipop82.png)

* 页表基址寄存器：页表在主存中的存储地址；
* 因为页表是存储在主存里面的，每次需要访存操作，根据局部性原理，现在访问#0号逻辑号，接下来的一段时间还是可能访问这个，所以引入了**快表**；

#### 地址变换过程（增加TLB）

* TLB（快表）：加快地址变换的速度，使用了SRAM,而主存使用了DRAM；且快表是一种相联存储器，可以按内容寻访；快表很容易被存满，所以也存在**替换**的问题；
* **地址变换过程**：首先，cpu要执行一段指令，要将逻辑页号转化为物理地址，先在快表中找，找不到，访问页表，转化为物理地址，先看在Cache中找，找不到在内存中找；另外根据局部性原理，将现在用到的页表中的那个页表项存到快表中；

​![image.png](assets/net-img-1693211428975-7290817b-ea9c-4054-bcd3-1995592a46c3-20231017224855-fzfdlam.png)​​

#### 本节回顾

​![image.png](assets/net-img-1693211638648-c704e270-c0f5-46d1-9166-dd3125db51e9-20231017224855-0mykkzf.png)​

### 虚拟存储器

​![image.png](assets/net-img-1693212965185-3079200d-9517-4717-9422-f42d63212fbd-20231017224855-u2ri0m0.png)

#### 页式虚拟存储器

​![image.png](assets/net-img-1693213279586-f3809608-bce7-48a1-9275-9fcdfcb5d7b4-20231017224855-k1hrtig.png)​

一开始分好页后，并不会将其全部放到主存内部，有些没有，所以页表添加了外存块号为了找到对应外存快和有效位表示其有没有添加到主存内；  
添加了**访问位**是为了**实现页面替换算法**，主存和辅存之间的替换，脏位表示是否被修改过，决定当该块被淘汰时是否写回辅存

​![image.png](assets/net-img-1693213371502-94e4c6e1-d832-47d0-a8cf-afb55465f3fe-20231017224855-6ajk485.png)​

​![image.png](assets/net-img-1693213432093-5e13eded-9052-4e5a-b829-6cb9240e65fd-20231017224855-ir48glp.png)​

#### 段式虚拟存储器

​![image.png](assets/net-img-1693213535739-e81b3798-47be-460e-bd74-2095aef258cd-20231017224855-em103n9.png)​

​![image.png](assets/net-img-1693213615401-e8c3234a-b409-4627-834c-4fcd9309a622-20231017224856-6k9d18x.png)​

#### 段页式虚拟存储器

​![image.png](assets/net-img-1693213690427-b471483e-3ec9-43c1-9b09-90704c704ae6-20231017224856-5rlra36.png)​

# 第四章 指令系统

​![image.png](assets/net-img-1693291080747-2c36da87-e125-4d6f-9644-b0965e55f473-20231017224856-h2vtjq8.png)​

​![image.png](assets/net-img-1693291123772-7c131e52-413f-4abd-b24e-f33ba5dff297-20231017224856-qcooxew.png)​

​![image.png](assets/net-img-1693291177942-4e120715-a41f-4909-9ae9-459982fe4257-20231017224856-gap9npo.png)​

​![image.png](assets/net-img-1693291248997-4f6a053c-2934-438b-8503-ae83ec270a08-20231017224856-c9lpfhi.png)​

## 指令的定义

​![image.png](assets/net-img-1693291345777-b2662b81-cde8-485c-988d-8c060c2e5628-20231017224856-0w86iuu.png)​

## 指令格式

​![image.png](assets/net-img-1693291445811-6b734dce-a6ac-48f8-a915-3b5fa2461db1-20231017224856-lbkim49.png)​

### 指令-按地址码数目分类

#### 零地址指令

​![image.png](assets/net-img-1693291607616-cc1b2fbd-630d-4d15-b24c-3689b95c1b43-20231017224857-3ioto0x.png)​

* **零地址的运算类指令又称为堆栈运算指令，参与运算的两个操作数来自于栈顶和次栈顶单元**

#### 一地址指令

​![image.png](assets/net-img-1693291884306-d5eb4784-8fbe-4dd1-9f41-4a63bebd96bb-20231017224857-ut95ppm.png)​

#### 二，三地址指令

​![image.png](assets/net-img-1693292008611-3b043513-fa0b-4a98-9323-628a7a93b8ba-20231017224857-1hvsh7z.png)​

#### 四地址指令

​![image.png](assets/net-img-1693292100691-26765dc6-6ed8-4e53-a966-ad8eb8b65120-20231017224857-rlgcxo8.png)​

​![image.png](assets/net-img-1693292220307-7ced8de3-6d06-4aef-8b15-ef092401e6a5-20231017224857-ycqapa8.png)​

#### 1~4地址指令

​![image.png](assets/net-img-1693292256989-76a0ff4b-0355-4966-842e-5c971b0386bc-20231017224857-u00fitc.png)​

### 指令-按指令长度分类

​![image.png](assets/net-img-1693292426973-1e3780b1-58c1-472f-9b53-4abf612f87c4-20231017224857-ntbyusc.png)​

### 指令-按操作码长度分类

​![image.png](assets/net-img-1693292744274-1ca99c80-ae2a-462e-863a-2e2d5bf5f4e8-20231017224857-mpj4vjd.png)​

### 指令-按操作类型分类

​![image.png](assets/net-img-1693292950301-9a60d244-9426-4b6a-b711-e9f105a6ceb3-20231017224857-am1ah7a.png)

**注意：循环指令属于程序控制类**

### 其它

​![image](assets/image-20231210153832-f2ardrj.png)​

​![image](assets/image-20231210153841-lk1uw74.png)​

​![image](assets/image-20231210153851-9x6nvo4.png)​

### 本节回顾

​![image.png](assets/net-img-1693292998361-f5bb46aa-fb6f-4976-bae0-cbbe95498c46-20231017224857-psv6mj6.png)​

## 扩展操作码-指令格式⭐

* **定长指令字结构+可变长操作码→扩展操作码指令格式**

​![image.png](assets/net-img-1693293073869-3a3fad4a-7366-4012-8dab-8b5306225b0e-20231017224858-znrat3j.png)​

​![image.png](assets/net-img-1693293372538-85fed96d-3fbe-48c6-afa3-5707aea974d4-20231017224858-ml50fwp.png)​

​![image.png](assets/net-img-1693293468171-41224d1c-0e70-4990-b170-edf4bfde961c-20231017224858-qnp7pi3.png)​

* 注意：设计时，先从操作码从短到长，地址码多地址到少地址

​![image.png](assets/net-img-1693293767087-e3495de1-6621-46f9-ad79-d1e5062fde57-20231017224858-hiq6g3y.png)​

​![image.png](assets/net-img-1693293869980-62cf2d62-14ac-4e80-8628-0f3b8d28cbb7-20231017224858-1nqimp3.png)​

## 指令操作码

​![image.png](assets/net-img-1693293967841-380e4b17-43e7-426b-aef9-86dc424a6b4a-20231017224858-bibnj7i.png)​

## ⭐指令寻址:如何确定下一条指令的存放地址？下面是寻址方式介绍

|寻址|寻址方式||
| :-----------------: | --------------------------------------| --|
|顺序寻找|指令寻址||
|跳跃寻址|||
|直接寻址|数据寻址||
|间接寻址|||
|寄存器寻址|||
|寄存器间接寻址|||
|隐含寻址|||
|立即寻址|||
|基址寻址|||
|变址寻址|||
|基址&变址复合寻址|||
|相对寻址|||
|堆栈寻址|||

​![image.png](assets/net-img-1693296902092-54541de5-4295-437d-879c-65e8bc92993e-20231017224858-g2a1wy2.png)​

​![image.png](assets/net-img-1693297428451-2c301c2d-7678-44dd-8370-9740b8526e87-20231017224858-r0enf56.png)​

* **初始：指令字长为2B，且按字编址（字长=2B），所以每次pc+1就指向了下一个指令；**
* **修改后：若修改成按字节编址（1B），而指令长度还是2B，所以需要pc+2。**

### 顺序寻址

​![image.png](assets/net-img-1693297545985-8dd22d67-16f4-46c4-b7a2-a9a27570c0f1-20231017224858-wrf7oca.png)

  
​![image.png](assets/net-img-1693297662860-807bc343-dd28-4557-862f-7ac91dac6a7d-20231017224858-iera92o.png)

​![image.png](assets/net-img-1693297730770-e96e013e-5aec-4992-85a2-42cf08068afd-20231017224859-cs8ciuj.png)​

​![image.png](assets/net-img-1693297857467-be8fe959-4ff9-4bd1-a683-17171dd0b212-20231017224859-hykknhx.png)​

* **准确的说是：（pc）+指令字长n/按...编址 →pc**

​![image.png](assets/net-img-1693297912255-902c820f-04fb-44eb-acce-daa8ce3aab8b-20231017224859-lheluxd.png)​

### 跳跃寻址

​![image.png](assets/net-img-1693298123061-0a448230-d15c-412a-85c4-50a90733722c-20231017224859-dmf5wq0.png)​

### 本节总结

​![image.png](assets/net-img-1693298181317-14c512b1-413c-4c65-94b6-7123a9efef1d-20231017224859-h1uzpdi.png)​

## 数据寻址1

* 求出操作数的真实地址，称为有效地址(EA)

​![image.png](assets/net-img-1693298666285-a262f1a9-4e95-49c7-bb32-12786193ee0f-20231017224859-hd5nkz1.png)​

​![image.png](assets/net-img-1693298744503-f40c7fcd-4b19-43d0-a76d-d4d21d3f0e87-20231017224859-2734b70.png)​

​![image.png](assets/net-img-1693298812615-a92ef80d-38ae-440c-9feb-a93b4b5df47c-20231017224859-1wr70s1.png)​

​![image.png](assets/net-img-1693298875723-1c0c79c4-7c60-42d0-b2f9-775c6c794206-20231017224859-qydkcc1.png)​

### 直接寻址

​![image.png](assets/net-img-1693299022781-a83d4f29-fe66-4bba-aa4b-574e89b6b727-20231017224859-qawjv80.png)​

### 间接寻址

​![image.png](assets/net-img-1693299270268-3a41a115-c09d-40ab-a8b8-e5997aee9bf8-20231017224859-kahzsjt.png)​

### 寄存器寻址

​![image.png](assets/net-img-1693299413983-3cf34537-af66-4885-a920-a11253b54aaa-20231017224900-kouvvjf.png)​

### 寄存器间接寻址

​![image.png](assets/net-img-1693299474883-7a6a0f16-f79f-4965-895c-2e79941cce34-20231017224900-cjdti31.png)

### 隐含寻址

​![image.png](assets/net-img-1693299536999-62af6fe3-696f-4d06-829c-2c3a5843e480-20231017224900-uj20upq.png)​

### 立即寻址

​![image.png](assets/net-img-1693299637203-cafa82ab-82e3-4a10-bac5-d03d895d11e8-20231017224900-96382kq.png)​

### 本节回顾

​![image.png](assets/net-img-1693299662169-f7acd210-e9dc-4b89-8d39-c35a38d362b3-20231017224900-sp4fy3y.png)​

## 数据寻址2-偏移寻址

​![image.png](assets/net-img-1693384163806-09234e78-c62d-4381-be7c-f0b0b1033c02-20231017224900-9gq4kdq.png)​

​![image.png](assets/net-img-1693384265359-9f8fdecc-d87a-4b5f-a433-2fb24eb7f720-20231017224900-p01vox3.png)​

### 基址寻址

​![image.png](assets/net-img-1693384534927-6235bde4-2337-404b-9afb-d3734ba12d70-20231017224900-i115j87.png)​

下面为直接寻址

​![image.png](assets/net-img-1693384683207-e565b1e3-78e8-4417-acb3-7d559e277115-20231017224900-mcm8xb0.png)​

下面为基址寻址

​![image.png](assets/net-img-1693384765962-f3049b97-b060-4222-984f-701fedf2336e-20231017224901-v5z9dew.png)​

​![image.png](assets/net-img-1693384825894-b1ed418a-8151-43e0-ae55-d13b243f7669-20231017224901-88mh6f7.png)​

​![image.png](assets/net-img-1693384933102-aad09db2-4fd7-4db7-928c-d055b4462a03-20231017224901-38pm37f.png)​

### 变址寻址

​![image.png](assets/net-img-1693385010692-4b71ddf9-3408-41d2-9c12-f8db64d69d96-20231017224901-b8rnokc.png)​

​![image.png](assets/net-img-1693385167783-fe4230d4-cd40-4ac4-b76a-24752a9f64bb-20231017224901-zp271o6.png)​

**下面是使用变址寻址进行改造**  
​![image.png](assets/net-img-1693385437543-30c07a03-478b-4ef7-86a1-cbad0e685e17-20231017224901-ql85a1w.png)​

​![image.png](assets/net-img-1693385468539-2ecac150-c6d0-4d59-b920-1e8de478a918-20231017224902-2m7dway.png)​

### 基址&变址复合寻址

​![image.png](assets/net-img-1693385828207-4973b87a-81c7-449c-9f03-488729ffbe60-20231017224902-jc75xbv.png)​

### 相对寻址

​![image.png](assets/net-img-1693385980765-73194bef-37b1-45eb-adcd-184fd7615f8e-20231017224902-8fdv884.png)​

​![image.png](assets/net-img-1693386461709-97407a0b-d7db-4b6d-989a-58eea70b0df8-20231017224902-y3cdpbl.png)​

​![image.png](assets/net-img-1693386525837-6b6723e2-8300-4208-a52e-0d1dc63acf21-20231017224902-7ui3523.png)​

### 本节回顾

​![image.png](assets/net-img-1693386597282-194305c2-d66d-405c-87c7-cade04afda5e-20231017224902-kgfcnal.png)​

### 硬件如何实现”数“的比较

​![image.png](assets/net-img-1693386884128-432cffb6-8771-4178-9cfa-1bc405898f90-20231017224903-92t3v8a.png)​

## 数据寻址3-堆栈寻址

​![image.png](assets/net-img-1693386917770-5f9debcf-1922-49c7-9a3c-6f64aedb3fc1-20231017224903-3a15bam.png)​

​![image.png](assets/net-img-1693387095185-088738cd-03ab-41c8-9977-c1b51a9bef1f-20231017224903-3zz8mb0.png)​

​![image.png](assets/net-img-1693387203140-517b4624-0286-45d3-b22e-0217d1564f14-20231017224903-80ez7xi.png)​

​![image.png](assets/net-img-1693389215336-3d2bf8a0-c760-4e6f-8a56-60d0ee0ea88d-20231017224903-efv3z5z.png)​

### 本节回顾

​![image.png](assets/net-img-1693389288354-3c19ed36-3ad1-4d83-ade8-aae41ee2abcb-20231017224903-jqudsl3.png)​

## 高级语言与机器级代码之间的对应

​![image.png](assets/net-img-1693389380722-abec9a9d-572c-40fc-b44c-69aced3f35a6-20231017224903-we68cgo.png)​

​![image.png](assets/net-img-1693389582423-982c6358-e3de-4653-bc8d-294237c415a6-20231017224903-4w1rzsy.png)​

​![image.png](assets/net-img-1693389830153-96da2f34-39b5-4c1f-b5c0-46539e97fa2e-20231017224903-038bzgg.png)​

### 解决数据在哪儿的问题？

​![image.png](assets/net-img-1693390069256-25bc7452-0633-4f9d-b432-dd88b6f4b725-20231017224904-zp5faip.png)​

#### x86架构，有哪些寄存器？

​![image.png](assets/net-img-1693390333115-f7371466-d197-465c-8683-808d50d26663-20231017224904-j56f3ft.png)​

E开头的寄存器，表示内部有**32bit**数据

  
​![image.png](assets/net-img-1693390395125-83acbd14-08e0-406f-ab70-26d4433c467d-20231017224904-0s1sgn7.png)

如果仅仅想要使用通用寄存器后面的16bit可以使用ax，bx，cx，dx而不加前面的e（扩展）

  
​![image.png](assets/net-img-1693390475041-9f0e4a82-0b80-4662-8cbf-fc5be8181a02-20231017224904-ra3jv5q.png)

还可以通过上面的方法将16bit分为两个8bit使用

  
​![image.png](assets/net-img-1693390705562-2d4fa112-3772-4c0b-9673-db4f28664df2-20231017224904-ybe826z.png)

第一条：将寄存器ebx中存储的主存地址的32bit复制到eax寄存器中；  
......  
注意：未指明长度，默认32bit

#### 本节回顾

​![image.png](assets/net-img-1693390822280-6af31808-f4d4-4c5d-aa31-67c0e4073dc7-20231017224904-kyemqw4.png)​

### 解决怎么处理的问题？

​![image.png](assets/net-img-1693390979938-f7f40bfc-2998-4d98-a052-712976c1a7e5-20231017224904-z4mnm69.png)

#### 算术运算指令

  
​![image.png](assets/net-img-1693391294458-e7d09fe6-2176-4d75-94b7-13d46600ba3b-20231017224904-op2fli2.png)​

除法运算之前，会进行位扩展，，将32bit扩展为64bit

‍

​![image.png](assets/net-img-1693391500529-d6c08063-2345-4ec1-9596-a9819329e9f7-20231017224905-czwh4px.png)

**注意：①左边操作数不可能是常量**，因为要把数据最后再存到这；**②不允许两个操作数都来自于主存**，因为那样太慢了

#### 常见的逻辑运算指令

​![image.png](assets/net-img-1693391575048-70333b1d-cf32-4bbc-80cb-cb5e910cbebf-20231017224905-avvcx58.png)​

#### 其他指令

  
​![image.png](assets/net-img-1693391703893-293a551b-69d8-4b55-bf4d-5d9ad6b503b0-20231017224905-ok2ffjb.png)​

## AT&T模式   vs   Intel模式

​![image](assets/image-20231116180544-hctuma9.png)​

**之前的学的是Intel格式**  
​![image.png](assets/net-img-1693472008709-184d315d-3bcf-4f5e-b2b1-cb2b85fded1f-20231017224905-raceefx.png)

**注意：上面的表注意最下面那个	，下面有解释**  
​![image](assets/image-20231116181111-0ppo6ud.png)​

## 选择语句-机器级表示

​![image.png](assets/net-img-1693545722077-f46fe2d4-baec-4640-84d6-ef8579a88106-20231017224905-1pz7wkx.png)  
​![image.png](assets/net-img-1693545891836-4ddb2a36-7081-4b53-9193-d9de62767e80-20231017224905-629pqde.png)  
​![image.png](assets/net-img-1693546044137-72384417-eff4-4a18-a50d-62e6335ec12e-20231017224905-o5u8yhm.png)  
​![image.png](assets/net-img-1693546260809-019d37c0-786f-4500-94bb-3d79dfe3f776-20231017224905-23f9uve.png)  
​![image.png](assets/net-img-1693546380927-635dd440-3139-42f4-8c73-46d2f59524e7-20231017224906-y8fsimz.png)  
​![image.png](assets/net-img-1693546504883-c8dfb6ef-7bfe-4245-bb9d-6775a8288aac-20231017224906-tvhzn4u.png)  
​![image.png](assets/net-img-1693546649548-2fb68c73-dd72-4073-8425-e24f46878800-20231017224906-uqoyz42.png)​

​![image.png](assets/net-img-1693546990522-403d8554-d0c6-473a-b011-bd3fb8a65589-20231017224906-3a3zaw2.png)​

## 循环语句--机器级表示

​![image.png](assets/net-img-1693547183519-3969dfee-5b73-4b65-99c6-cb3d80a42726-20231017224906-rrdke53.png)​

​![image.png](assets/net-img-1693547265183-24899210-fba7-4438-94dc-0b646efe5984-20231017224906-0qugrbo.png)​

​![image.png](assets/net-img-1693547658247-276c7b76-732a-427e-ac60-00af4a4a8ae7-20231017224906-7uktbuz.png)​

**注意：** loop指令默认指定了**ecx**，因为ecx可以作为循环计数器。

## 函数调用--机器级表示

### call与ret

​![image.png](assets/net-img-1693547772871-f36eb9fa-b718-405b-8a3c-b7944e23562a-20231017224907-b2p1m0c.png)​

​![image.png](assets/net-img-1693547793339-20e53782-dace-4573-88de-b2fd2afaa2b9-20231017224907-10qqqpj.png)​

​![image.png](assets/net-img-1693547805484-cf69c1bc-2b27-4104-bafc-9d0f58e4ef60-20231017224907-qscc7bm.png)​

​![image.png](assets/net-img-1693547842498-823d71ec-717d-40c1-976b-a2c33ce75e7d-20231017224907-en7bu6c.png)​

​![image.png](assets/net-img-1693547855569-cf0cb862-8b81-4d48-b3ee-a461fca45adc-20231017224907-b100f9n.png)​

​![image.png](assets/net-img-1693547872747-aca7c4fb-6b7a-4a5a-869f-4355364ab517-20231017224907-57ax3yq.png)​

​![image.png](assets/net-img-1693547883806-9f1c1039-7980-4bdf-899f-ede6e06ee21a-20231017224907-rke0thw.png)​

​![image.png](assets/net-img-1693547903120-4172aa28-b89b-4c45-aeae-b26cc37af2f9-20231017224907-7nz3kn1.png)​

​![image.png](assets/net-img-1693547975088-a7e9d0fd-55b8-4445-be73-36b06c6a3570-20231017224907-b37xyhj.png)​

​![image.png](assets/net-img-1693548076751-3dfd6385-93d3-45b7-a6c6-7702d9e0ab93-20231017224908-o9s8a4d.png)​

​![image.png](assets/net-img-1693548099987-1ddf12c7-5914-4c76-90c7-1c15c96f4e21-20231017224908-rj6bgxy.png)​

​![image.png](assets/net-img-1693548168989-cc40b6b7-a01a-4803-ad06-e89c103073a8-20231017224908-i9deez3.png)​

​![image.png](assets/net-img-1693548215528-568e2b39-0f2e-4b3b-af60-0ad777e9fe4e-20231017224908-trl8ctw.png)​

### 如何访问栈帧？

​![image.png](assets/net-img-1693548329537-34d73dc2-974d-41b4-87c8-9282d4a3c0b7-20231017224908-u0iak7t.png)

#### 栈为什么倒过来了

​![image.png](assets/net-img-1693548399814-717bdeb1-a33f-4aaa-bb36-11df1308b11c-20231017224908-ctksie3.png)

#### 标记栈帧范围：EBP,ESP寄存器

  
​![image.png](assets/net-img-1693548480340-a0bed4cf-588f-4dc5-96c8-55857808bfd0-20231017224909-7t9n2ed.png)​

注意：每一个栈帧的顶部就是自身的**ip（pc）旧值，即返回地址**；

  
​![image.png](assets/net-img-1693548529897-9c44fe5b-b660-4a70-9d4d-177672fb57ec-20231017224909-1hvjcds.png)

​

**add方法结束之后，退出栈**

​![image.png](assets/net-img-1693548562491-d34a0e26-5777-4187-9cb5-1d95577c0bd7-20231017224909-2ipi4nm.png)

  
​![image.png](assets/net-img-1693548785522-5ced067d-ef56-4a1e-ae9d-c20d5fbe7ebb-20231017224909-1bpelkw.png)​

push eax：先将栈顶指针esp-4，再将eax寄存器中的值211放到栈顶；  
push 985：先将栈顶指针esp-4，再将985放到栈顶；

​![image.png](assets/net-img-1693548882165-b38b592b-3dc9-49f3-b70c-b2156a1e4a07-20231017224909-xsx2rxp.png)​

push[ebp+8]：先将栈顶指针esp-4，再将内存地址为 **[ebp+8]** 中的数据666放到栈顶；  
注：这里 **[ebp+8]** 就是ebp指针指向的地方上面2个格子，因为一个格子4字节，

‍

  
​![image.png](assets/net-img-1693548949579-dea94187-bb64-4842-9eb5-dc3a510855ff-20231017224909-lojmafz.png)

pop eax：**参照上图是变化前**，栈顶存的是**666**，将**666弹出**放到**eax寄存器**中，**eax寄存器**数值变化为**666**，同时，**esp+4**

  
​![image.png](assets/net-img-1693549026266-3d860b8a-5871-4f3d-a2af-00c1ecee3d57-20231017224909-lfzmr9k.png)

执行最后一个：  
pop [edp+8]：此时栈顶指针esp指向985，将985弹出放到ebp+8地址，同时esp+4；过程如图，结果图在下面

​![image.png](assets/net-img-1693549040167-1f9a9ff6-0591-4702-a051-68b255dd02e0-20231017224909-bpkxww7.png)

‍

#### 访问栈帧数据：mov指令

​![image.png](assets/net-img-1693549195462-454d6820-5dad-4bf4-926e-0c1e27292b8b-20231017224910-m3x5zfx.png)

始终栈顶栈底指针**只能**访问栈顶和栈底，有什么方法可以访问其他位置呐？  
**mov指令**

​![image](assets/image-20231117171025-lylxaka.png)​

执行完sub esp，12之后esp指向这里；  
使用sub，add修改esp的指向地址

‍

‍

‍

​![image.png](assets/net-img-1693549354226-a757329c-e50d-4a31-b4f2-0292422f68aa-20231017224910-wscy820.png)​

​![image.png](assets/net-img-1693549399613-ac896eb9-4893-4551-a84b-e3009220cbb3-20231017224910-v9jn5b6.png)  
​![image.png](assets/net-img-1693549424257-2a0845bf-c295-4864-a9cd-5ecc161f9063-20231017224910-vjf6yaw.png)​

#### 总结：如何访问栈帧

​![image.png](assets/net-img-1693549544673-33ce05c9-5b8d-42e9-8a6b-8d64a6cdabaf-20231017224910-4izneln.png)​

‍

### 如何切换栈帧？

​![image.png](assets/net-img-1693643873374-4b1abbb9-ea11-48c5-b21a-0fefbca8a9b7-20231017224910-02cb8kq.png)

**注意：
每一个栈帧的底部存放的是上一个栈帧的底部地址；（每个函数开始的例行处理：push ebp；mov ebp，esp）
每一个栈帧顶部存放的是自己的IP(PC)旧值（返回地址）（这是call方法协助实现的）** 

  
​![image.png](assets/net-img-1693643972772-c5fc15e0-bed3-4fb6-8882-762e58d3fa8e-20231017224910-pp2cqtk.png)

​![image.png](assets/net-img-1693644031171-9362a4ad-ab9a-4831-ac7b-0e3a536920b1-20231017224910-xz6stkm.png)​

​![image.png](assets/net-img-1693644114645-7a79f340-c81b-4bc8-a6ee-1c8a2b025f0b-20231017224910-orgw5w5.png)​

‍

​![image.png](assets/net-img-1693644177773-c5eaa5f5-dc6b-4e3b-953f-cbe20803c9ec-20231017224911-i4t0c23.png)​

push 寄存器，到底是存的寄存器里里面的内容啊，还是寄存器地址啊

  
​![image.png](assets/net-img-1693644292233-e6bdb580-4984-4526-88ee-69e466447307-20231017224911-0vmunyj.png)

‍

  
​![image.png](assets/net-img-1693644331990-c0d143c5-6b0f-4bf5-93e8-07aad29bb41b-20231017224911-lnl3uak.png)

这里的mov复制的是寄存器的地址吧

  
​![image.png](assets/net-img-1693644343187-49a86471-5e51-4bbe-b399-3ed042e03ba7-20231017224911-45qz7wa.png)

‍

  
​![image.png](assets/net-img-1693644362566-cec2c29e-81f3-465e-bbb3-47285020d4a9-20231017224911-v5g9xjl.png)​

注意：因为是pop操作，所以完事之后**esp+4**指向上一栈帧的底部，这里存放着上一栈帧的ip旧址

‍

  
​![image.png](assets/net-img-1693644394684-5d1de6ec-f3d2-4d8f-b341-c603c1e830af-20231017224911-jf3ec9r.png)

**leave指令：就是从这个栈帧返后到上一个栈帧**

  
​![image.png](assets/net-img-1693644466238-c87a5c0e-1698-4b8a-bc5b-32bcac8f3181-20231017224911-u1cdmpj.png)

注意：在**leave指令**之后还有一个**ret指令**

​

#### 本节回顾⭐

​![image.png](assets/net-img-1693644571790-81bb008e-b55b-4629-b7bf-d7be15aff155-20231017224912-2dyp5ch.png)

#### 例题

​![image.png](assets/net-img-1693644632262-171e7cd8-60d5-4e9b-8430-0c0d7541dcaf-20231017224912-4tz9sk4.png)​

​![image.png](assets/net-img-1693644728034-1eb7ad16-3692-4891-b04c-f5ef2fbb738c-20231017224912-1dgc825.png)​

### 栈帧内包含哪些内容？参数，返回值传递

​![image.png](assets/net-img-1693644856502-8ac3169a-d86e-42db-b1ca-8ced7fc8adf1-20231017224912-9wrao3o.png)​

​![image.png](assets/net-img-1693645228901-94ef5c2e-2c8a-4e05-9616-1d128282936b-20231017224912-9bo7dl9.png)​

​![image.png](assets/net-img-1693645346182-27bb4932-4dd3-45c7-87e4-32663d0aa505-20231017224912-kvujywz.png)​

​![image.png](assets/net-img-1693645509251-4671d133-f45f-4ce2-967e-ae05d11524fc-20231017224912-sjmi2av.png)​

​![image.png](assets/net-img-1693645653904-84b145b3-f811-4091-bad4-a2939790539f-20231017224912-jvtib5r.png)​

### 汇编代码实战

​![image.png](assets/net-img-1693645997133-877c1b35-64de-4b77-b660-8f5da1e00f6e-20231017224913-jwiworf.png)​

​![image.png](assets/net-img-1693646029651-c3d14dfb-69b9-44da-b18f-2baf7ee87d41-20231017224913-fpwxi7z.png)​

​![image.png](assets/net-img-1693646056836-45180552-c69d-4c8d-9815-60c657ad38fb-20231017224913-sjqahrp.png)​

​![image.png](assets/net-img-1693646153009-6af088d2-9d1f-4ead-812e-6521ea950f52-20231017224913-eg3axh2.png)​

​![image.png](assets/net-img-1693646176513-bd932f33-b2dd-47ca-ab13-ed03d202cba2-20231017224913-62n3er8.png)​

​![image.png](assets/net-img-1693646198205-33f53ca1-8c0f-41c3-90dd-03f9effeed0b-20231017224913-ra8vvsp.png)​

​![image.png](assets/net-img-1693646318003-ed0149cd-471d-46b8-9703-313f1a9e79a9-20231017224914-rg3rf5x.png)​

**一般返回值都是放在eax寄存器内的**

### 本节回顾

​![image.png](assets/net-img-1693646467204-3b28e969-50d4-4642-b906-a95d4fed1007-20231017224914-omzm3q5.png)​

​![image.png](assets/net-img-1693646601800-04ccff74-1753-447b-a586-6c35cf7d3b31-20231017224914-ztazeha.png)​

​![image.png](assets/net-img-1693646629448-afcfa9d9-0056-41f3-8ce5-f51dfe05bfa9-20231017224914-o78fu1s.png)  
​  
​![image.png](assets/net-img-1693646651545-fff44f44-a649-465f-8206-ea7f06a40045-20231017224914-o5my9v0.png)​

### 本节总结

![image.png](assets/net-img-1693646727673-106b6bb1-2b5e-472b-9357-7fa532c6b052-20231017224914-rl42f6m.png)

## CISC和RISC⭐⭐

​![image.png](assets/net-img-1693649604814-447e7c33-35b1-4afd-bfda-b593506797b4-20231017224914-uqvd11d.png)

左上**一个指令寻址，下面一个数据寻址**

**复杂指令集系统与精简指令集系统**
![image.png](assets/net-img-1693649978949-62ccc97c-7ccb-478e-9c1f-aa795921d56d-20231017224915-fhxhf3t.png)​


![image.png](assets/net-img-1693650051833-3f487fcf-c91d-4a95-857b-39a8349b18bb-20231017224915-tsvhd4z.png)​

### CISC和RISC的区别

​![image.png](assets/net-img-1693650157037-229a3f59-d182-460e-861e-26f39c7ae3f2-20231017224915-wc148m6.png)​

**Load：读某个主存单元，读到某一个寄存器当中**
**Store：从某一个寄存器当中往主存当中写一个数据**


![image.png](assets/net-img-1693650346621-2d2568b2-00c6-44f3-b5a2-3d48e62fd1fa-20231017224915-0zla1i5.png)​

# 第五章 中央处理器（CPU）

​![image.png](assets/net-img-1693650602171-b07be82c-5b3d-495f-98db-a015e86e2375-20231017224915-0gvyjx7.png)​

​![image.png](assets/net-img-1693650622733-88850629-b651-4b46-a649-f83a6c9276e4-20231017224915-s8i5v0z.png)​

​![image.png](assets/net-img-1693650758445-cefe66d2-f05a-42b6-aad5-cd8bd99c4a41-20231017224915-s1suevg.png)​

​![image.png](assets/net-img-1693650985971-b9aa1022-a162-4bb7-8546-e8eb359dfe08-20231017224915-ovq14pe.png)​

## CPU的功能和基本结构⭐⭐

​![image.png](assets/net-img-1693725402803-de44dbc9-6506-4853-adb2-3289d01b4d4b-20231017224916-b1vsgh0.png)​

​![image.png](assets/net-img-1693725585127-5f4bdb83-e969-4842-8b37-7dcb5380e88c-20231017224916-vd3w5xw.png)​

### 运算器的基本结构

​![image.png](assets/net-img-1693725762204-450cd50c-5ffb-4caf-b138-ad2786a67a7c-20231017224916-ecvsid1.png)​

**左右都是寄存器，右边就是文中写的AX,BX,CX,DX**

​![image.png](assets/net-img-1693726007121-b5b48226-11a5-4016-9d05-43d738b7bed8-20231017224916-ijzjuj0.png)​

每次输入输出分别都有一个，所以使用多路选择器MUX

​![image.png](assets/net-img-1693726102703-e6b6fbde-9a91-4426-889a-0b4466a45eb5-20231017224916-339cpk7.png)​

三态门有三个接口，一个输入，一个输出，一个RXout，控制哪个导通，哪个不导通

 **...in是寄存器的输入信号，...out是寄存器的输出信号**

​![image.png](assets/net-img-1693726666313-a09f2fe6-b9df-4f39-be3c-ed1b298ab2a5-20231017224916-zve3rm3.png)​

下面的暂存寄存器说是为了防止数据冲突，同时输出R0，R1时，先把R0输出到总线上，数据会被放在暂存寄存器中；接下来撤销R0的输出有效信号，然后使R1导通，把R1的数据输出到B；

上面的暂存寄存器和三态门是因为：在R0输出到B上时，还没稳定上面就输出结果到了R0，将R0覆盖了，所以添加一个暂存寄存器，当稳定之后，打开三态门输出数据到R0

**RXin表示输入信号，RXout表示输出信号，看着像是随便输入，其实不是**  
​![image.png](assets/net-img-1693726836738-8b08731e-6590-4308-bb39-46f769c726a8-20231017224916-1erzkj7.png)​

### 控制器的基本结构

​![image.png](assets/net-img-1693727550803-9c31d71c-7c2f-4f95-8a42-1fafee98888d-20231017224917-ct7mquq.png)​

### cpu的基本结构

​![image.png](assets/net-img-1693727648821-22f1765a-9920-4de1-b3a5-bfe17253ce6d-20231017224917-zohunuj.png)​

​![image.png](assets/net-img-1693727672504-ca684dd7-6d01-4107-9f50-8f3f8aa75cff-20231017224917-fm1s5ge.png)​

‍

​![image.png](assets/net-img-1693727714566-318ff5e9-cad5-4573-8d95-c66d2c8e1e88-20231017224917-3cl8ca7.png)​

### 本节回顾

​![image.png](assets/net-img-1693727763262-0ecb6081-c84c-42c2-9f8e-00c78fd9d227-20231017224917-njj1i7h.png)​

## 指令执行过程⭐⭐

​![image.png](assets/net-img-1693727846058-6467602c-99c3-41dc-b2bf-08a448906478-20231017224917-ye88v3i.png)​

### 指令周期⭐

关于指令周期，机器周期与时钟周期

​![image.png](assets/net-img-1693728082557-36d16ea4-2301-4a70-b627-8f01c740ffdb-20231017224917-c0sc10w.png)​

​![image.png](assets/net-img-1693728381046-67cb9a32-6394-4afc-84df-6c943568d5b3-20231017224917-le8pvn5.png)​

​![image.png](assets/net-img-1693728650988-173060cc-9075-4f41-b03d-257ee3c78af1-20231017224917-le9euwh.png)​

指令周期流程和各阶段的访存操作

​![image.png](assets/net-img-1693728782221-82d7e524-25e9-4f7e-b9ad-8c90493b812c-20231017224917-nspsr9w.png)​

**通过触发器来判断处在哪个周期**

### 指令周期的数据流-取指周期

​![image.png](assets/net-img-1693729037906-84c11d59-0201-407b-a9d6-53f9d5b826c3-20231017224918-9llewft.png)​

### 指令周期的数据流-间址周期

​![image.png](assets/net-img-1693731286501-33674d9c-8de9-43b6-a1f5-c19496edb6fd-20231017224918-jur0g81.png)​

### 指令周期的数据流-执行周期

​![image.png](assets/net-img-1693731322172-d8d84e0f-ce29-4401-89e9-f621337daafd-20231017224918-cnzmyoq.png)​

### 指令周期的数据流-中断周期  **p345**看书更方便

* 中断周期：暂停当前的程序（任务），去执行其它的程序（任务）；
* 每个**程序（任务）** 有多个指令；
* 例如：当前**程序（任务）** 执行完指令2之后**进行中断检查**，看是**否有中断信号需要处理**；如果有就去执行**中断处理程序**，**它也有多个指令组成**，执行完中断处理程序的指令之后，接着从原先程序的指令3开始执行；  
  **为了能够回到原先的程序，需要保存pc的值，用堆栈保存：首先使（sp）-1→sp指针指向栈顶，然后将（sp）→MAR，这里便是将要存放pc的地址；**   
  然后cu发出写信号，所以 **（pc）→MDR：pc的值放到MDR中**

​![image.png](assets/net-img-1693731796734-3c93651a-74e7-4093-8282-02b0823697d1-20231017224918-vxa6eyq.png)​

之后执行**中断处理程序第一条指令x**，需要**修改pc的值**将pc指向这里的指令x，这个操作时cu完成的（将中断处理程序的入口程序放到pc中）

​![image.png](assets/net-img-1693732076051-c387f65c-9007-43b6-9328-7cd3541084a8-20231017224918-q0s7izt.png)​

**数据流向：**

1. **CU控制将SP减1，SP---&gt;MAR---&gt;地址总线---&gt;主存**
2. **CU发出写命令---&gt;控制总线---&gt;主存**
3. **PC---&gt;MDR---&gt;数据总线---&gt;主存（程序断点存入主存）**
4. **CU（中断服务程序的入口）---&gt;PC**

### 指令执行方案：连续执行多个指令的指令执行方案

​![image.png](assets/net-img-1693734084198-ff1d9000-6486-49df-8a7c-008b58197a94-20231017224918-0znq8s5.png)​

这个图像类似于多体并行存储器⭐

### 本节回顾

​![image.png](assets/net-img-1693734102114-e40b9b62-7bb1-40af-96a4-5466d9543413-20231017224918-8jgwk92.png)​

**这四个标志触发器时为了说明指令周期执行到哪里了**

## 数据通路的功能 单总线结构

​![image.png](assets/net-img-1693734436653-19bf874a-9be2-4609-af1a-045cb2f2e1bd-20231017224918-rf7ob3u.png)​

### 1.寄存器之间数据传送

​![image.png](assets/net-img-1693734681627-a5db6da5-8f99-4ff7-98db-d473e2085394-20231017224919-6b8u4a9.png)​

### 2.主存和cpu之间的数据传送

​![image.png](assets/net-img-1693735012619-201b343b-605b-465e-9938-88d96d54a6f5-20231017224919-viqnd7e.png)​

### 3.执行算术或逻辑运算

​![image.png](assets/net-img-1693735486867-33490bc9-84b7-44a5-987e-06497d7bb15b-20231017224919-cdsva19.png)​

​![image.png](assets/net-img-1693735541591-039dc97f-bd5c-4870-8851-b2495062b725-20231017224919-6v13kbb.png)​

​![image.png](assets/net-img-1693735566963-f5a5323f-df45-42bf-a1ae-703c3aceda0e-20231017224919-9w8g1rj.png)​

### 内部单总线-例题

​![image.png](assets/net-img-1693735950693-36e48d5f-9c94-4e87-9d06-7e686db223f5-20231017224919-g7l0c1k.png)​

​![image.png](assets/net-img-1693735964626-ea9ffebc-24ae-42c7-96d2-511b6da7ad61-20231017224920-zelbfre.png)​

​![image.png](assets/net-img-1693736064232-fbf36a34-cfef-48c1-9d56-e17b4b37c5c2-20231017224920-2zy0fwy.png)​

​![image.png](assets/net-img-1693736167338-c7e46360-ade8-4c7d-b52a-cabf2b8d833f-20231017224920-uq88bgf.png)  
**注意：猜测：时序3，将MDR数据写入主存，是MARout，需要借助MAR中的地址**

### 本节回顾

​![image.png](assets/net-img-1693736189047-fcb48a12-9781-48e4-8af3-97d58e18350c-20231017224920-gtnk2ye.png)​

## 数据通路-专用通路结构

**在任意两个需要进行数据流动的部件之间都建立起一个专用的数据通路**

### 专用数据通路方式-取指周期

​![image.png](assets/net-img-1693736587595-498b54f3-e75c-49e0-a1d7-34923cd32dde-20231017224920-tum0y3o.png)​

### 专用数据通路方式-例题⭐

​![image.png](assets/net-img-1693736674485-bd3235f5-40c3-4000-9562-e3b9b50cdd80-20231017224920-mb2u5sl.png)​

  
​![image.png](assets/net-img-1693736815976-1b3474b4-710d-4306-ba78-43a33723169d-20231017224920-x0skl6b.png)​

​![image.png](assets/net-img-1693736984902-c21b6a66-9ef0-44c6-8b3d-95e5db0ee16e-20231017224921-u3kpyko.png)​

​![image.png](assets/net-img-1693737147656-f55b6ec9-9d1b-4da7-8111-5616c5308d6b-20231017224921-35k31zm.png)​

​![image.png](assets/net-img-1693737378064-9c778224-4bdc-49ec-94a7-3c108dafd634-20231017224921-o7j5ob7.png)​

​![image.png](assets/net-img-1693737495899-dca11a60-056b-43b3-bc32-169372f97071-20231017224921-s6bwy0a.png)​

​![image.png](assets/net-img-1693737604727-5f65435a-d358-4fd8-8b45-c1695fa23adf-20231017224921-drhyw55.png)​

### 本节回顾

​![image.png](assets/net-img-1693737621514-111398a3-6fd0-4041-99bf-08991a9bf3c7-20231017224921-pykxnns.png)​

## 控制器设计⭐⭐

### 硬布线控制器-**纯硬件实现控制器**

#### 本章总览

​![image.png](assets/net-img-1693813308077-3af4b49e-6a83-41ad-801a-f03ae391249f-20231017224921-h0w6gz4.png)​

#### 内容回顾-微命令，微操作⭐

​![image.png](assets/net-img-1693813793548-90d1b167-1174-4272-b005-ebe218309827-20231017224922-hl206z8.png)​

**执行每个指令时，都可能有这麽几个取指等周期，根据定长/不定长的机器周期（上面是定长的，有3个T0,T1，T2），给每个取指等周期分配若干个时钟周期，在每个时钟周期上执行微操作。**

​![image.png](assets/net-img-1693814339482-75010959-deaf-4e72-a162-65403e53c40a-20231017224922-ab29fwr.png)​

**上面都是定长的机器周期**

#### 微操作命令逻辑表达式-例题

​![image.png](assets/net-img-1693814339482-75010959-deaf-4e72-a162-65403e53c40a-20231017224922-ab29fwr.png)​

* 上面蓝色的说明哪个指令，右边紫色的线说明哪个机器周期，左边的节拍发生器说明哪个节拍；几者综合决定了执行哪个**微命令，微操作**

​![image.png](assets/net-img-1693814767502-cac3d7f9-50b4-41c8-86e7-38df2f07944a-20231017224922-7rn87ya.png)​

#### 硬布线控制器的设计

​![image.png](assets/net-img-1693815021632-e94bc72f-a387-4740-b917-503bd9abea81-20231017224922-yx88257.png)​

##### 分析每个阶段的微操作序列

​![image.png](assets/net-img-1693815860876-6318dcaf-4b09-4a67-8286-54330edecf38-20231017224922-ytkrt3h.png)​

##### 安排微操作时序的原则及安排

**本题安排定长机器周期，每个阶段3个时钟周期**

​![image.png](assets/net-img-1693816367878-55ca8e4b-1d93-4e56-9013-c91623491f39-20231017224922-vg3hya0.png)​

###### 取指周期的微操作时序安排

​![image.png](assets/net-img-1693816739268-fe331712-a946-46e6-96a7-179e99114e57-20231017224922-cr8mrib.png)  
**按照上面的说法，（3）和（4）是不能放到同一个时钟周期内的；不对，原则三允许有先后顺序**

###### 间址周期的微操作时序安排

​![image.png](assets/net-img-1693816897647-0e742c8b-53a0-45ec-8d80-957781156741-20231017224922-06x0ajt.png)​

###### 执行周期的微操作时序安排

​![image.png](assets/net-img-1693817200836-cd452cd1-4aef-428a-a6d6-a1175ac46f52-20231017224923-cy6f2dh.png)​

##### 组合逻辑设计

​![image.png](assets/net-img-1693817272526-3793fc4a-7e84-44a9-acaa-567cfc6b8209-20231017224923-rui26hz.png)​

###### 1.列出操作时间表

​![image.png](assets/net-img-1693817542518-a645a837-0c37-4b06-b93e-b4c25d60a8a4-20231017224923-v8oqfpy.png)​

**非访存指令通常不包含间址周期，而访存指令可能会包含额外的间址周期**

​![image.png](assets/net-img-1693817651426-86e0a29f-737d-42b2-86ba-b77819eb2f08-20231017224923-0ratzu9.png)​

  
​![image.png](assets/net-img-1693817757977-db31a54c-59f5-496f-97d1-4ae99d1495ac-20231017224923-mhqede9.png)​

###### 2.写出微操作命令的最简表达式+画出逻辑图

​![image.png](assets/net-img-1693814767502-cac3d7f9-50b4-41c8-86e7-38df2f07944a-20231017224923-dmod3gz.png)​

解：

​![image.png](assets/net-img-1693817939093-4ccf83f3-4b0e-486b-bddf-ec6e94ee2507-20231017224923-odjd1a6.png)​

​![image.png](assets/net-img-1693818031552-8247b303-a2ac-4f3c-82dd-07dff040b111-20231017224923-imah1k9.png)​

#### 本节总结

​![image.png](assets/net-img-1693818307976-03c6fc38-fadb-4921-8711-b40a7cf4f919-20231017224923-gl1ib0d.png)​

### 微程序控制器

#### 微程序控制器的基本原理

​![image.png](assets/net-img-1693835010125-22f409c2-c9d0-4eba-97b1-27a48075938f-20231017224923-3muxijd.png)  
**回顾一下上节课**  
​![image.png](assets/net-img-1693835086405-b9caed92-1d50-4b41-9d55-3beeb512d756-20231017224923-jv56w1l.png)​

#### 微程序控制器的设计思路⭐

​![image.png](assets/net-img-1693835661345-69819c96-16ce-4b2e-ab45-c5d62afaaa3d-20231017224924-c4ay82t.png)​

#### 微程序控制器的基本结构

**下面是cu控制单元的内部**

​![image.png](assets/net-img-1693836440406-2d0b8081-d873-40f7-a745-66e6fe68ff69-20231017224924-369yyqa.png)​

控制存储器CM存储**指令（微程序）** ，微程序由一系列**微指令序列**组成，这些**微指令序列顺序存储**在CM中，见图左上角。  
为什么由ROM组成？读的快，非易失性存储芯片

​![image](assets/image-20231123174752-lmcmzcv.png)​

将**CU内部的组件**和**外部CPU与主存**对照理解：  
**外部：pc→MAR→通过译码器→在主存读到之后放到MDR→IR；**   
**CU内部：CMAR→通过译码器→在控制存储器CM中读取→CMDR
注意：①CU内部的CMAR算是MAR和pc的结合**  
②CMDR存放微指令，所以他的位数同微指令字数相等

​​​​![image](assets/image-20231123191522-qwe8if0.png)​​​​

**机器指令****被取到IR中，不同的**​**机器指令****对应着不同的**​**微程序即微指令序列** **，根据**​**机器指令的操作码****确定他所对应的**​**微程序的起始地址** **→这是微地址形成部件的作用；**   
**顺序逻辑：确定微指令序列中指令执行的顺序；
将地址传送给CMAR，通过地址译码器在CM中取得微指令，将**​**微指令****传给CMDR，微指令中指明了**​**下一条微指令的地址**

**正如上图右上角思考所说，**​**所有指令的取指周期，间址周期，中断周期对用的微指令序列是一致的** **，所以在**​**CM****中这三个对应的微指令序列只有一份；见下图**

#### 微程序控制器的工作原理-模拟取数指令的执行过程

**LDA X：将主存地址为X中的数据放到ACC中；**

##### **取指周期**

​![image.png](assets/net-img-1693836865484-7202ecab-3703-493c-b5eb-fbaa3e583d98-20231017224924-lbhnlff.png)​

​![image](assets/image-20231123192825-015hlhj.png)​

* ‍

##### **执行周期**

​![image](assets/image-20231123193528-i63hdhg.png)​

##### **中断周期**

**执行周期结束，下一个微指令地址为0，还要看看是否有**​**中断信号** **，没有中断信号，直接跳到0；有的话跳到8**

​![image.png](assets/net-img-1693837033332-5a2338f8-bba0-4d54-8fa7-03376cc4133b-20231017224924-dpu2kv6.png)​

##### **补充**⭐

​![image.png](assets/net-img-1693837547006-6ba0351d-0d03-40db-8d39-5bab4fe945f4-20231017224924-vw14oli.png)​

为什么说指令系统n条指令，CM中微程序至少n+1条？

* 因为取指周期都是一致的，所以设置了一个**公用微程序**存放**取指周期对应的微程序；**
* 另外n条是对应**n条指令**的**执行周期的微程序；**
* 因为问的是**至少**，所以间址周期和中断周期可以忽略
* **微程序段至少n+1条/微程序至少n个**

#### 本节回顾

​![image.png](assets/net-img-1693837594574-05228e21-b8a2-416b-a772-cfcaab97b565-20231017224924-ufwbm0r.png)​

#### 微指令的设计

​![image.png](assets/net-img-1693894706968-bb7ec1b6-98e7-443d-9bd7-b9b8cbe07aa5-20231017224925-o1um9tc.png)​

​![image.png](assets/net-img-1693895610402-522b1f5e-0f2e-465e-8780-69432fe149dd-20231017224925-zpl8d95.png)​

##### 微指令的格式

​![image.png](assets/net-img-1693895871068-800b85b3-e033-44df-a4d5-f61e9389e32c-20231017224925-3a7ch6f.png)​

##### 微指令的编码方式-水平型指令

###### 1.直接编码

​![image.png](assets/net-img-1693896156999-4f093bdd-923d-4ecd-b385-d9c3d6e286b4-20231017224925-q2xhcuu.png)​

###### 2.字段直接编码方式

​![image.png](assets/net-img-1693896394941-13ed585a-1313-49f2-93d3-8f7057dd8aa0-20231017224925-lefuvf2.png)​

​![image.png](assets/net-img-1693896567335-fdada3d3-37f6-441f-8812-f39d01ddda52-20231017224925-qhw8gew.png)​

**例题：**

​![image.png](assets/net-img-1693896792911-0c1415a4-43ae-45c2-8a93-6bca5c36d723-20231017224926-dgqiel8.png)​

###### 3.字段间接编码方式（隐式编码）

​![image.png](assets/net-img-1693896887326-596f69d0-e461-402c-bbfa-484e6be09196-20231017224926-nogum1p.png)​

**译码两次**

##### 微指令的地址形成方式

​![image](assets/image-20231124191909-8rdhd0o.png)​

5中测试网络是指：**顺序逻辑**中接收外部信号决定接下来的微指令的存放地址地址：**了解即可**

​![image](assets/image-20231124192716-xmgptjx.png)​

​![image](assets/image-20231124192136-5i9pvwi.png)​

###### 第一种方式-断定方式-例题

​![image.png](assets/net-img-1693904194260-a6c41411-8fc6-483c-a6fd-70749e2b41e4-20231017224926-eyj5wbh.png)​

​![image.png](assets/net-img-1693904206719-9367326f-3613-470a-b842-bca2f41406bc-20231017224926-nhx03mh.png)​

##### 本节回顾

​![image.png](assets/net-img-1693904233558-7f8cda29-6759-455d-979d-e4cb3211432d-20231017224926-nc8mfhq.png)​

#### 微程序控制单元的设计

​![image.png](assets/net-img-1693904540470-bb6be936-d343-4e79-bbe6-68c18262a039-20231017224926-kzv25y6.png)​

​![image.png](assets/net-img-1693904540514-dd82bfc1-89d9-4ff0-b7b6-40c0685d9291-20231017224926-ht9ohuo.png)​

​![image.png](assets/net-img-1693904867595-7abecc24-4d24-4bfa-8df1-0763393055ca-20231017224927-8vr5kmc.png)​

​![image.png](assets/net-img-1693905073039-f6f8e8fa-a140-431f-9cb6-9ff99f86964e-20231017224927-smfgbwc.png)​

**王道书上是下面这样**

​![image.png](assets/net-img-1693905115783-236ef319-9363-4e13-8622-8fc619203e32-20231017224927-v542i3d.png)​

​![image.png](assets/net-img-1693905361175-457cc500-c651-481e-bb4d-71e79431fbc3-20231017224927-wafep8j.png)​

**执行周期完事了怎么办？**

​![image.png](assets/net-img-1693905414839-89064b3e-3adc-4114-a919-ba76665c7b2b-20231017224927-nvz68v5.png)​

​![image.png](assets/net-img-1693905656820-8b3a7840-bb77-4ced-ad1b-bf834561f646-20231017224927-9kn8hp6.png)​

##### 微程序设计分类

​![image.png](assets/net-img-1693905798801-8c49de17-20a0-48d9-9595-2db64ac32999-20231017224927-wx551w1.png)​

#### 硬部件控制器与微程序控制器的比较

​![image.png](assets/net-img-1693905978716-70175293-a6c3-4247-96a8-1b5809039f65-20231017224927-xqpik6x.png)​

#### 微程序控制器回顾

​![image.png](assets/net-img-1693906121342-4eb8bf0c-1de0-4e06-bbdf-d5b8dd0423e1-20231017224928-er7wfxv.png)​

## 指令流水线：本节好像都是理想条件：一个机器周期一个时钟周期⭐⭐

​![image.png](assets/net-img-1693906240406-6e13b2f3-2825-4264-a93a-65a99951080a-20231017224928-vxseu6b.png)​

### 基本概念

#### 流水线的定义

​![image.png](assets/net-img-1693906864780-0ab13a3a-89e1-4a61-a09e-4956fed28bc1-20231017224928-tq7b98j.png)​

​![image.png](assets/net-img-1693907057450-b0be5e92-7eed-4a24-8fa2-13baf85fd672-20231017224928-csuy112.png)​

#### 流水线的表示方法⭐

​![image.png](assets/net-img-1693907556534-9f764189-4099-495d-bfd8-61f4c177f46f-20231017224928-pjo5hg2.png)​

### 性能指标

#### 1.吞吐量⭐

​![image.png](assets/net-img-1693907919706-4e8996aa-4d3d-4a47-ad5b-b03228674a34-20231017224928-h02sthy.png)​

##### 补充：**装入时间与排空时间的概念**

​![image.png](assets/net-img-1693908012709-9c28da65-c655-4df0-8a44-718110b0c37a-20231017224928-l1z6vfs.png)​

#### 2.加速比

​![image.png](assets/net-img-1693908106604-5e10abca-28a8-46a5-83d6-a731a3999a22-20231017224929-ctye5at.png)​

#### 3.效率

​![image.png](assets/net-img-1693908416540-816da587-2478-48aa-ab3b-8c6fade497d4-20231017224929-pia4xw7.png)​

#### 本节回顾

​![image.png](assets/net-img-1693908493140-b38e5b52-8286-4405-8d50-f010cf36ecee-20231017224929-q9xm5uc.png)​

### 影响因素⭐

#### 机器周期的设置

* 经典的**五段式流水线**：**IF:取指；ID：指令译码；EX:执行；M：访存；W：写回到通用寄存器组。**

* 下方五段式流水线是MIPS（第一个RISC精简指令集系统）架构提出来的指令流水线
* **有的机器周期是不执行东西的，但是跑不掉，不能直接跳过**
* **每个机器周期时间修改成一致的，方便指令流水线的制作**
* **因为机器周期都修改成最长的了，有一段真空期，但是数据要传到下一阶段，所以在机器周期中间都有暂存寄存器，下一个机器周期需要的时候，再把数据送出去**
* 基本步骤

  * 1. IF：根据PC所指向的位置去****找出当前要执行的指令，然后将取到的指令存到中间的锁存器里
    2. ID：指令译码阶段，除了完成**指令译码的操作**外，还会**完成取数操作**，将****中的数据存到**锁存器A,B**里面，看到中间要有个名为imm^(前面是立即寻址)^的锁存器，这是存**立即数**的
    3. EX：对**操作数进行处理**，将**运算结果存到后面锁存器中**
    4. M：这个机器周期是要**进行访存**，原本是**访存主存**，但是这里是Data Cache^(这个是cache，是主存数据的副本，一般情况下，命中概率还是很高的，另外这是个存储数据的Cache)^，前面的数据可能会写回主存，也可能不写回主存，下面就有一个线是直接存到锁存器，然后在第五个阶段写回通用寄存器
    5. WB：把之前的结果写回到**通用寄存器**，也可能不写回
  * **两个Cache的存在独立，确保他两个可以并行的工作，从而第一阶段和第四阶段的硬件部件可以并行的工作，**
  * 使用Cache不使用主存也有缺陷，如果Cache不命中，可能导致断流，先不考虑

    * **ID可能读这个寄存器，而WB可能写入这个寄存器，可能造成问题**

​![image.png](assets/net-img-1693909904204-9c67edd4-a874-4c69-930a-4b9335d7544f-20231017224929-vdwxpmu.png)​

#### 影响流水线的因素

​![image.png](assets/net-img-1693910082861-cd7a6bcd-2620-43a0-9614-d83ea2f3785e-20231017224929-1wqaqu5.png)​

##### 1.结构相关（资源冲突）

​![image.png](assets/net-img-1693910241891-d55395ee-8e36-4c56-8643-f241418275de-20231017224929-csm7vx8.png)​

* **第一阶段和第四阶段都可能访问主存;第二阶段可能读取寄存器，第五阶段可能写入寄存器**

  * 方案一：后一相关指令暂停一周期
  * 方案二：资源重复配置：**就是上面**机器周期的设置**的方案**

​![image.png](assets/net-img-1693910295994-15a2dd9a-4517-45d3-b967-e3c7c5c3faa8-20231017224929-69vg8or.png)​

##### 2.数据相关（数据冲突）⭐

* 就是指令有相关性，必须这个执行完了，才能执行那一个

###### 1-①.硬件阻塞（stall）

​![image.png](assets/net-img-1693910578014-1bd8c914-299e-42b9-a0a0-9b0435879271-20231017224929-fmtuoye.png)​

​![image.png](assets/net-img-202310180016848-20231113184754-yhlk2n9.png)​

###### 1-②.软件插入"NOP"

**nop方式：在生成机器指令的时候，编译器发现前后两条指令有数据冲突，编译器会在两条指令中间插入三条空指令（**​**具体插几条，由编译器完成，具体问题具体分析** **），**​**每个空指令都会完成完整的五个周期**

​![image.png](assets/net-img-202310180016849-20231113184755-kz131zt.png)​

###### 2.数据旁路技术（转发机制）

​![image.png](assets/net-img-202310180016850-20231113184755-it3o77f.png)​

###### 3.编译优化

​![image.png](assets/net-img-202310180016851-20231113184756-lcykpft.png)​

##### 3.控制相关（控制冲突）

* **函数调用call，函数的返回指令都会引起断流，还有中断，去处理中断处理程序**

​![image.png](assets/net-img-202310180016852-20231113184756-8zj6r4c.png)  
​![image.png](assets/net-img-202310180016853-20231113184757-t5w8ucy.png)​

### 流水线的分类

​![image.png](assets/net-img-202310180016854-20231113184757-rzz28rl.png)​

​![image.png](assets/net-img-202310180016855-20231113184758-jnkp4s9.png)​

### 流水线的多发技术

​![image.png](assets/net-img-202310180016857-20231113184758-r22s141.png)​

​![image](assets/image-20231126025358-fnsa0sh.png)​

​![image.png](assets/net-img-202310180016858-20231113184759-qczrp8o.png)​

​![image.png](assets/net-img-202310180016859-20231113184759-7hx714r.png)​

### 本节回顾

​![image.png](assets/net-img-202310180016860-20231113184800-k3s554y.png)​

### 五段式指令流水线

​![image.png](assets/net-img-202310180016861-20231113184800-4r6aqlu.png)​

​![image.png](assets/net-img-202310180016862-20231113184801-q54yj51.png)​

#### 运算类指令的执行过程

​![image.png](assets/net-img-202310180016863-20231113184801-3yjc8o3.png)​

#### LOAD指令的执行过程

​![image.png](assets/net-img-202310180016864-20231113184802-sb0jp36.png)​

#### STORE指令的执行过程

​![image.png](assets/net-img-202310180016865-20231113184802-st6ufp0.png)​

#### 条件转移指令的执行过程

​![image.png](assets/net-img-202310180016866-20231113184803-y019dgo.png)​

#### 无条件转移指令的执行过程

​![image.png](assets/net-img-202310180016867-20231113184804-dgbeegi.png)​

#### 例题

​![image.png](assets/net-img-202310180016868-20231113184804-1jp1fz5.png)​

## 多处理器基本概念

​![image.png](assets/net-img-202310180016869-20231113184805-c9k7xxc.png)9

​![image.png](assets/net-img-202310180016870-20231113184805-r2d5heo.png)​

​![image.png](assets/net-img-202310180016871-20231113184805-dbgc6h3.png)​

​![image.png](assets/net-img-202310180016872-20231113184806-mea4a8v.png)​

​![image.png](assets/net-img-202310180016873-20231113184807-5osh37o.png)​

​![image.png](assets/net-img-202310180016874-20231113184807-8eabp5a.png)​

​![image.png](assets/net-img-202310180016875-20231113184808-djhji23.png)​

​![image.png](assets/net-img-202310180016876-20231113184808-xtkzhn1.png)​

​![image.png](assets/net-img-202310180016877-20231113184809-za3xgg6.png)​

​![image.png](assets/net-img-202310180016878-20231113184809-p1n9uhn.png)​

## 硬件多线程的基本概念

​![image.png](assets/net-img-202310180016879-20231113184810-vap1taj.png)​

​![image.png](assets/net-img-202310180016880-20231113184810-qcm1tos.png)​

​![image.png](assets/net-img-202310180016881-20231113184811-5mccdz3.png)​

‍

​![image.png](assets/net-img-202310180016882-20231113184811-og0ova3.png)​

​![image.png](assets/net-img-202310180016883-20231113184812-2sw8jns.png)​

# 第六章 总线

​![image.png](assets/net-img-202310180016884-20231113184812-7qluzm1.png)​

​![image.png](assets/net-img-202310180016885-20231113184813-7008996.png)​

​![image.png](assets/net-img-202310180016886-20231113184813-4ymgklk.png)​

## 总线的定义

​![image.png](assets/net-img-202310180016887-20231113184814-p5x1vsh.png)​

## 总线的特点

​![image.png](assets/net-img-202310180016888-20231113184814-i1j9g1v.png)​

## 总线的特性

​![image.png](assets/net-img-202310180016889-20231113184815-wfywg8l.png)​

## 总线的分类⭐⭐

​![image.png](assets/net-img-202310180016890-20231113184815-f583b78.png)​

### 总线分类-按数据传输格式

​![image.png](assets/net-img-202310180016891-20231113184816-s34kg6u.png)​

**并行总线一定比串行总线更快**   ❌

### 总线的分类-按总线功能

​![image.png](assets/net-img-202310180016892-20231113184816-4wofiro.png)​

​![image.png](assets/net-img-202310180016893-20231113184817-ntrmqhy.png)​

​![image.png](assets/net-img-202310180016894-20231113184817-95vj0n5.png)​

**并行总线一定比串行总线更快，这是错的**​​​​

## 系统总线的结构

​![image.png](assets/net-img-202310180016895-20231113184818-hdunyy5.png)​

**上面缺点中的并发，就是在操作系统中的并发**

​![image.png](assets/net-img-202310180016896-20231113184818-uidlk4i.png)​

**使用通道可以缓和cpu和各种io设备之间的速度矛盾**

​![image.png](assets/net-img-202310180016897-20231113184819-gpcfn8z.png)​

​![image.png](assets/net-img-202310180016898-20231113184819-rbe18tl.png)​

**使用通道可以缓和cpu和各种io设备之间的速度矛盾**

​![image.png](assets/net-img-202310180016897-20231113184819-gpcfn8z.png)​

​![image.png](assets/net-img-202310180016898-20231113184819-rbe18tl.png)​

## 本节回顾

​![image.png](assets/net-img-202310180016899-20231113184820-o6xkz6c.png)​

## 总线的性能指标⭐⭐

​![image.png](assets/net-img-202310180016900-20231113184820-mb6v50s.png)​

​![image.png](assets/net-img-202310180016901-20231113184821-3m6jq74.png)​

​![image.png](assets/net-img-202310180016902-20231113184821-vjuam8p.png)​

​![image.png](assets/net-img-202310180016903-20231113184822-wm9nf42.png)​

​![image.png](assets/net-img-202310180016904-20231113184823-935f5ix.png)​

​![image.png](assets/net-img-202310180016905-20231113184823-kakhozx.png)*8

### 本节回顾

​![image.png](assets/net-img-202310180016906-20231113184824-gmuqdox.png)​

## 总线仲裁⭐⭐

**如何解决多个设备征用总线的问题？** 

​![image.png](assets/net-img-202310180016908-20231113184825-eqtwmf8.png)​

### 集中仲裁方式

**总线控制器****可能集成在**​**cpu/桥接器内部** **，**​**总线时钟信号****也是由**​**总线控制器****发出的**

BG，BR，BS属于控制总线，它们都是一根线

​![image.png](assets/net-img-202310180016909-20231113184825-qlrdlrx.png)  

#### 链式查询方式

**设备发起请求信号，**​**总线控制部件****检测到有设备发起请求就传输**​**总线允许信号** **，设备接收到到信号之后**​**向BS发起信号表示占据了总线资源** **，这时，总线控制部件收回BG信号**

​![image.png](assets/net-img-202310180016910-20231113184826-sxdsjm8.png)​

​![image.png](assets/net-img-202310180016911-20231113184826-bq0oe2t.png)​

​![image.png](assets/net-img-202310180016912-20231113184826-ggwjfro.png)​

#### 计数器查询方式

**设备发起请求信号BR，总线控制器接收到信号之后，判断总线是否空闲，空闲的话计数器开始计数，计数值通过**​**设备地址线发向各设备** **，当设备发现计数值与自己的地址一致时，发起BS信号，占用总线资源，直到使用完成，收回BS信号，总线控制器又开始工作....**

​![image.png](assets/net-img-202310180016913-20231113184827-c9ernrj.png)​​​

#### 独立请求方式

**注意：少画了BS总线忙控制线，每个都和它连接**

​![image](assets/image-20231127024853-u1d86kl.png)​

#### 集中仲裁方式小结

​![image.png](assets/net-img-202310180016915-20231113184828-5qi6uhb.png)​

### 分布仲裁方式

​![image.png](assets/net-img-202310180016916-20231113184829-qr1sm0z.png)​​​

### 本节回顾

​![image.png](assets/net-img-202310180016917-20231113184829-4i97cp8.png)​

## 总线操作和定时⭐⭐

​![image.png](assets/net-img-202310180016919-20231113184830-dm4siqq.png)​

### 总线传输的四个阶段

**总线控制器 提供统一时钟信号**

​![image.png](assets/net-img-202310180016920-20231113184830-j6ellkb.png)​

​![image.png](assets/net-img-202310180016921-20231113184831-8iv1u9e.png)​

​![image.png](assets/net-img-202310180016922-20231113184831-0uvqswu.png)​

​![image.png](assets/net-img-202310180016923-20231113184832-yhh4aeb.png)​

​![image.png](assets/net-img-202310180016924-20231113184832-sb2xuab.png)​

​![image.png](assets/net-img-202310180016925-20231113184833-cx0i6ir.png)​

​![image.png](assets/net-img-202310180016926-20231113184834-apsqcg5.png)​

### 本节回顾

​![image.png](assets/net-img-202310180016927-20231113184834-0i73ugs.png)​

## 总线标准

​![image.png](assets/net-img-202310180016928-20231113184834-tbdw1a1.png)​

​![image.png](assets/net-img-202310180016929-20231113184835-6gitap9.png)​

​![image.png](assets/net-img-202310180016930-20231113184835-vltjac6.png)​

​![image.png](assets/net-img-202310180016931-20231113184836-uedwnyw.png)​

​![image.png](assets/net-img-202310180016932-20231113184837-ur7dvyj.png)​

​![image.png](assets/net-img-202310180016933-20231113184837-9s52a2v.png)  

上面vesa是一种**并行总线**；收到**cpu控制**，导致工作频率被限制；下面的pci就不会被cpu控制，所以更快，取代了vesa；  
pci当初也和cpu相连作为系统总线，所以一些教科书说pci使系统总线也是对的

​![image.png](assets/net-img-202310180016934-20231113184838-cv0kzd4.png)​

​![image.png](assets/net-img-202310180016935-20231113184838-obrmd9p.png)​

​![image.png](assets/net-img-202310180016936-20231113184839-k84pv8i.png)​

全双工：我给你发，你也给我发

​![image.png](assets/net-img-202310180016937-20231113184840-4pyvpic.png)​

​![image.png](assets/net-img-202310180016938-20231113184840-ol82w01.png)​

scsi是一种并行总线

​![image.png](assets/net-img-202310180016939-20231113184841-xh71jaf.png)​

pcmcia是并行总线

​![image.png](assets/net-img-202310180016940-20231113184842-mtjaotg.png)​

​![image.png](assets/net-img-202310180016941-20231113184842-jya0qav.png)​

​![image.png](assets/net-img-202310180016942-20231113184843-8ait6ty.png)​

ide（ata/pata）是并行的

​![image.png](assets/net-img-202310180016943-20231113184843-zcqtyz7.png)​

​![image.png](assets/net-img-202310180016944-20231113184844-v40b1p3.png)​

### 本节回顾

![image.png](assets/net-img-202310180016945-20231113184845-9qzstc0.png)

### 补充：为何串行总线取代并行总线

​![image.png](assets/net-img-202310180016946-20231113184845-kda0q6c.png)​

​![image.png](assets/net-img-202310180016947-20231113184846-4hehb1f.png)​

# 第七章 输入/输出系统

​![image.png](assets/net-img-202310180016948-20231113184846-xrd7zl0.png)​

​![image.png](assets/net-img-202310180016949-20231113184847-sca1wcr.png)​

## I/O基本概念

​![image.png](assets/net-img-202310180016950-20231113184847-4yrvlcp.png)​

​![image.png](assets/net-img-202310180016951-20231113184848-7neo26w.png)​

* I/O控制器是一块芯片，常被集成在**主板**上；现在也会被集成在**南桥芯片内部**​​

## I/O控制方式

### 程序查询方式和程序中断方式

​![image.png](assets/net-img-202310180016953-20231113184849-jfrujwn.png)​

​![image.png](assets/net-img-202310180016954-20231113184850-b3cc314.png)​

### DMA控制方式

​![image.png](assets/net-img-202310180016955-20231113184850-43bsgtn.png)​

​![image.png](assets/net-img-202310180016956-20231113184851-thfjrrg.png)​

### 通道控制方式

​![image.png](assets/net-img-202310180016957-20231113184851-elr0tto.png)​

​![image.png](assets/net-img-202310180016958-20231113184852-tbxwwdu.png)​

## IO系统基本组成

​![image.png](assets/net-img-202310180016959-20231113184853-6dtanpk.png)​

## 本节回顾

​![image.png](assets/net-img-202310180016960-20231113184853-u2oj9zd.png)​

## 外部设备

​![image.png](assets/net-img-202310180016961-20231113184854-goqvk41.png)​

​![image.png](assets/net-img-202310180016962-20231113184854-p86qamk.png)​

​![image.png](assets/net-img-202310180016963-20231113184855-roktu6x.png)​

​![image.png](assets/net-img-202310180016964-20231113184855-7h17ho0.png)​

​![image.png](assets/net-img-202310180016965-20231113184856-2wwi6tn.png)​

​![image.png](assets/net-img-202310180016966-20231113184857-z7qirha.png)​

​![image.png](assets/net-img-202310180016967-20231113184857-g9vg9sp.png)​

​![image.png](assets/net-img-202310180016968-20231113184858-9vfrdwx.png)​

​![image.png](assets/net-img-202310180016969-20231113184858-4jd2mb4.png)​

​![image.png](assets/net-img-202310180016970-20231113184859-dwo0oog.png)​

​![image.png](assets/net-img-202310180016971-20231113184900-wohogi6.png)​

​![image.png](assets/net-img-202310180016972-20231113184900-jnrucya.png)​

​![image.png](assets/net-img-202310180016973-20231113184901-ws4fv1h.png)​

## I/O接口

​![image.png](assets/net-img-202310180016974-20231113184901-tx1bnfq.png)​

​![image](assets/image-20231127163454-c2pcyut.png)​

### 接口的作用

​![image.png](assets/net-img-202310180016975-20231113184902-tt0hdh7.png)​

​![image.png](assets/net-img-202310180016976-20231113184902-0x48ry6.png)​

​![image.png](assets/net-img-202310180016978-20231113184903-1u3nq9e.png)​

### 工作原理

​![image](assets/image-20231127164111-j1q11vz.png)​

* io接口接收到命令字（控制字）后，会在io控制逻辑的指挥下对设备发出控制信号/电信号
* 命令字又叫控制字

​![image](assets/image-20231127164439-wozmk7x.png)​

下面红色部分是传输数据的时候（图示是打印数据）

​![image](assets/image-20231127164826-k5vvbay.png)​

* **cpu如何检查状态寄存器**

  *  轮询检查
  * 通过控制线给cpu发送中断请求信号

* 工作流程-cpu要输入/输出数据

  * cpu给**控制寄存器**发送**命令字**
  * **io控制逻辑**取出**控制寄存器**中这条命令，此时，**控制寄存器空闲**
  * io控制逻辑启动设备的工作，设备需要给cpu传送设备状态，可以把状态信息给状态寄存器

**为什么将状态寄存器和控制寄存器合二为一？**

​![image.png](assets/net-img-202310180016980-20231113184904-8hdpgfp.png)​

* **一开始是控制寄存器接受cpu的信号，后面是状态寄存器接收设备/I/O控制器的状态**

​![image.png](assets/net-img-202310180016981-20231113184905-0s7jcua.png)​

* **io端口：指的是io控制器中的各种寄存器，**
* **io总线的作用**

  * 地址线的作用：cpu会通过地址线来指明他要往那个寄存器中读/写数据
  * 控制线的作用：读/写io端的信号，中断请求信号
  * 数据线：cpu输入/输出的数据；还有状态字，命令字等；还有**中断类型号**

    * 中断原因可能是完成任务了，也可能是设备故障了，中断类型通过数据线传输

* 刚才说，一个I/O控制器连接多个外设，而cpu要操作的是哪个设备那，对于设备的选择信息是怎么传递的那？

  * 有的是通过**地址线**传输的：地址线还要指明**cpu要读/写的寄存器**外，也有可能传输具体的设备编号，但是要分开两次进行；
  * 还有一些是，连多个外设，每个外设都要有3个对应的寄存器，多一个外设，多一组数据+状态+控制寄存器

​![image.png](assets/net-img-202310180016982-20231113184905-1m0inb0.png)​

#### 接口和端口

​![image.png](assets/net-img-202310180016984-20231113184906-2vle5cl.png)​

**可以使用统一编制和独立编制两种方法对端口进行编制**

##### I/O端口编制方式---统一编制vs独立编址

RISC机器只有两个访存指令：LOAD和STORE

​![image.png](assets/net-img-202310180016985-20231113184907-yk8bs5i.png)​

​![image](assets/image-20231127172932-xmm1yf3.png)​

​![image.png](assets/net-img-202310180016986-20231113184907-q1tdveo.png)​

​![image.png](assets/net-img-202310180016987-20231113184908-ktljgsi.png)​

### I/O接口类型

​![image.png](assets/net-img-202310180016988-20231113184908-kgrny90.png)​

​![image.png](assets/net-img-202310180016989-20231113184909-2z74rey.png)​

## I/O控制方式

### 程序查询方式

​![image.png](assets/net-img-202310180016990-20231113184909-3kxmdh2.png)​​​

​![image.png](assets/net-img-202310180016992-20231113184911-tzrs4ze.png)​

#### 模拟-程序查询方式-打印3个字符abc⭐

​![image.png](assets/net-img-202310180016993-20231113184911-henx8wn.png)​![image](assets/image-20231206153656-w786m45.png)​​

* x86中的两个io指令：in ， out
* io端口是指io接口中的寄存器
* **模拟的过程-打印三个字符**⭐

  * 首先，三个字符要是在内存中则放到寄存器中，还有可能直接在寄存器中
  * CPU将**命令字(打印)** 通过**数据线**给**控制寄存器R**~**n+1**~，这是一个**OUT指令**

    * **命令字**数据放到**数据线**传给**控制寄存器**，
    * **地址线**传送该**命令字**要放的**地址R**~**n+1**~
    * **控制线**发出**写命令** **，将**​**命令字****写到**​**R**~**n+1**~**控制寄存器中**
  * **IO控制逻辑**将cpu发送的**打印命令信号**传送给打印机（**通过控制线发出相应的控制信号**），**打印机启动**
  * 打印机通过**状态线**给**IO接口**发送**状态信息** **（** 表示**准备就绪**的状态信息），**IO控制逻辑**将状态信息送到**状态寄存器**
  * 因为现在是**程序查询方式**，所以刚刚cpu发送完命令字之后，一直**轮询检查**状态寄存器

    * 怎么样完成轮询检查呐？cpu一直执行**IN指令**，将**状态寄存器中的数据**输入的寄存器中检查
  * cpu要打印第一个字符了：

    * 一个OUT指令：地址线为**R**​~**n**~，控制线**写信号**，数据线上**是要打印的数据a**，数据a被送到**数据缓冲寄存器**
    * IO控制逻辑将Rn中的数据a通过线（前面的线是通用的那一段，后面是一段**数据线**）传送给打印机，输出a
    * **打印**的时候**状态寄存器**是一个**忙碌的状态**，**打印完成之后**通过**状态线**给**IO接口**返回打印已完成的信号，**IO接口**将**状态寄存器**的**忙碌状态修改为就绪状态**
    * 于此同时，cpu一直在轮询检查状态寄存器，看到**状态寄存器**从**忙碌状态**变成**就绪状态**，cpu继续向数据缓冲寄存器传入第二个字符b，其它一切照旧
    * 全部打印完成之后（cpu中设置一个计数器i=3，每次减1，直到0），cpu向**io接口**发出**停机命令字，在io控制逻辑**的指导下传送给**打印机，** 打印机停止工作

​![image.png](assets/net-img-202310180016994-20231113184912-hcx2jec.png)​

#### 程序查询方式流程图

​![image.png](assets/net-img-202310180016002-20231113184916-nai5bhd.png)​

#### 程序查询方式-例题

​![image.png](assets/net-img-202310180016003-20231113184917-7bzhc19.png)​

#### 本节回顾

程序查询方式，一种是独占查询，就是之前讲的那样，还有一种是定时查询

​![image.png](assets/net-img-202310180016004-20231113184918-nnz7yt1.png)​

‍

### 程序中断方式⭐⭐

​![image.png](assets/net-img-202310180016005-20231113184918-oc0wwc8.png)​

#### 中断的基本概念

​![image](assets/image-20231127215045-m7nxajf.png)​

* cpu如何知道自己是否处于关中断的状态那？

  * **注：** 如果cpu执行了关中断指令，接下来cpu不会响应任何一个中断请求；
  * **存在PSW中，见下图**
  * ​![image](assets/image-20231127224737-ilpt4ed.png)​

* 不同的中断请求由不同的中断服务程序来完成
* cpu如何响应一个中断信号呐？**就是上面的工作流程**

#### 工作流程-中断请求

##### 中断请求的分类

​![image.png](assets/net-img-202310180016007-20231113184919-mxwuryo.png)​

* **关机**就是**非屏蔽中断，必须被响应**

##### 中断请求标记：如何判断是那个设备发来的中断信号

​![image.png](assets/net-img-202310180016008-20231113184920-sb6h5oa.png)​

##### 中断判优：有多个中断信号同时到来，先处理哪个？

###### 中断判优的软硬件实现

​![image.png](assets/net-img-202310180016009-20231113184920-qx1iyku.png)​

###### 中断判优-优先级设置原则

​![image.png](assets/net-img-202310180016010-20231113184921-akqqaqj.png)  

#### 工作流程-中断响应

不同的中断请求由不同的中断服务程序来完成

​![image.png](assets/net-img-202310180016011-20231113184921-2ghs8vc.png)​

* **中断处理过程**：

  * （找到对应中断服务程序的入口：中断隐指令帮助完成）
  * （处理中断前需要保存pc值，这由中断隐指令完成，执行完中断服务程序之后，使pc恢复）
  * 初始pc指向k，开始执行指令，期间pc→k+1，有中断需要处理，接下来需要**保存现在的pc值，，并使pc指向中断服务程序的第一条指令**：**中断隐指令**

##### 中断响应过程-中断隐指令

* 中断隐指令指的是**一系列的指令**，并不是指一个特殊的指令；但都是**cpu自动完成**的

* 中断隐指令的主要任务

  * 1.关中断：防止中断服务程序被打断
  * 2.保存断点：**保存pc的值**
  * 3.引出中断服务程序：**使pc指向中断服务程序的初始地址，**​**如何找到呐？** 

    * 软件查询法
    * 硬件向量法

​![image.png](assets/net-img-202310180016012-20231113184922-3zq2gk0.png)​

###### 如何找到**中断服务程序的初始地址**？-硬件向量法

* 如何用**硬件向量法**找到**中断服务程序的初始地址**？

  * 左边的排队器是前面**多个中断信号时中断判优时的设备**，只选择一个，所以只有一个1，
  * 经过**中断向量地址形成部件**产生相应的**向量地址**，**向量地址**中存放着**中断向量**（中断向量指向了中断服务程序入口）
  * 再由**向量地址存放的中断向量**找到**中断服务程序的初始地址即入口地址；**
* **向量地址**又叫**中断类型号，为什么不是中断类型号直接指向初始地址呐？⭐**

  * 因为中断服务程序可能被修改，下面的其它的中断服务程序的被往下挤，地址就发生变化了

​![image.png](assets/net-img-202310180016013-20231113184922-nqmhrdd.png)​

​![image.png](assets/net-img-202310180016014-20231113184923-rrh48o0.png)​

#### 工作流程-中断处理

##### 中断处理程序-中断服务程序

* 中断服务程序的主要任务

  * 1.保护现场
  * 2.中断服务：各不相同
  * 3.恢复现场：恢复第一步压入栈顶的数据+之前中断隐指令存的pc值
  * 4.中断返回

​![image.png](assets/net-img-202310180016015-20231113184924-951pt2a.png)​

#### 中断过程-总结

* **中断隐指令中保存断点****和**​**关中断****是**​**硬件同时****完成的**
* 中断处理过程：

  * 1.取指令，执行指令，检查是否有中断信号，如果没有则继续取指令执行指令，如果有中断请求，
  * 2.则先进行**中断隐指令**；

    * **执行关中断**，
    * **同时，** 将**pc值存到堆栈中**，
    * 再之后**将向量地址中存放的中断向量给pc**，
  * 3.完成**中断隐指令**之后，**pc指向中断服务程序**，进行**中断服务程序**；

    * 先**保护现场**，**将之前指令执行的数据存放到**​**堆栈****中**，
    * 然后进行**中断服务**（**设备服务）** ，完成之后再之后**恢复现场**，**开中断**
    * **中断返回**
* **单重中断** **：** 关中断到开中断期间为**原子操作，不可被打断**，不会被其它的中断请求打断，这叫**单重中断**。

* **处理中断时是一气呵成的，中间再有中断信号也不理会----**​**单重中断**

​![image.png](assets/net-img-202310180016018-20231113184925-g1ivits.png)​

#### 多重中断

​![image.png](assets/net-img-202310180016019-20231113184926-4hqkj78.png)​

‍

​![image.png](assets/net-img-202310180016020-20231113184926-cfxt1rr.png)​

* 关于什么是屏蔽字？

  * 又称中断屏蔽字
  * cpu在执行中断请求的时候，屏蔽字表面的要忽视哪些中断请求

#### 中断屏蔽技术

​![image.png](assets/net-img-202310180016021-20231113184927-htnpm6c.png)​

* ‍

​![image.png](assets/net-img-202310180016022-20231113184927-64tnz96.png)​

* **重要的是：①1表示屏蔽，0表示正常申请②屏蔽自身**

##### 中断屏蔽技术-例题

​![image.png](assets/net-img-202310180016023-20231113184928-n7raf51.png)​

​![image.png](assets/net-img-202310180016024-20231113184928-kv7mr7t.png)​

#### 中断系统小结

​![image.png](assets/net-img-202310180016025-20231113184929-696o1yx.png)​

一个ASCII码就是一个字节

#### 扩展

​![image.png](assets/net-img-202310180016026-20231113184929-mssos21.png)​

​![image.png](assets/net-img-202310180016027-20231113184930-tyhu5wz.png)​

#### 程序中断方式

​![image.png](assets/net-img-202310180016028-20231113184931-aj4oorl.png)​

* 通过io指令向io设备发送启动输入相关的命令，外部设备准备cpu需要的设备和信息，与此同时，cpu执行之前的程序
* io设备完成工作之后，向cpu发送中断请求信号，cpu在k程序运行末尾去**处理请求信号**

  * 执行中断隐指令
  * 执行中断服务程序

##### 程序中断方式-例题

​<kbd>第一问不做</kbd>

​![image](assets/image-20231128015156-ovvl5rw.png)​

​![image.png](assets/net-img-202310180016029-20231113184931-f8kghfn.png)​

#### 本节回顾

​![image.png](assets/net-img-202310180016030-20231113184932-8pec4jf.png)​

### DMA方式

​![image.png](assets/net-img-202310180016031-20231113184932-gfft35n.png)​

​![image](assets/image-20231128023141-md5qqoq.png)​

* 程序中断方式时，每次io设备准备好一个字的时候，cpu运行一遍中断服务程序，把这一个字的数据转存到主存当中
* DMA方式，需要一个专门的DMA控制器，这也是一种io控制器（io接口）

#### DMA控制器​​

​![image](assets/image-20231128024121-orxpdto.png)​

* 一共5个字，一次传一个，先传到DMA的数据缓冲寄存器，再传到主存
* 之后，DMA中的计数器5-1=4，**两边地址也变化了**​​

​![image.png](assets/net-img-202310180016036-20231113184935-vzpw7g6.png)​

​![image.png](assets/net-img-202310180016037-20231113184935-g32lgrc.png)​

#### DMA传送过程

* DMA请求：我们要和主存传输一个字的数据
* DMA中断请求：一整块的数据传输已经完成了

​![image.png](assets/net-img-202310180016038-20231113184936-oeeqh77.png)​

#### DMA方式的特点

* 在DMA控制器占用系统总线的时候，cpu也无法访问，所以有了下面的结构，多了一个DMA总线和主存总线
* 下面又造成了另一个问题，当cpu和DMA接口同时访问主存（假设不是双端口主存）时，响应谁

​![image.png](assets/net-img-202310180016039-20231113184936-rad28sk.png)​

#### DMA传送方式：解决上面cpu和DMA的访存冲突

下面又造成了另一个问题，当cpu和DMA接口同时访问主存（假设不是双端口主存）时，响应谁

​![image.png](assets/net-img-202310180016040-20231113184937-iw2mim4.png)​

#### DMA方式和中断方式

​![image.png](assets/net-img-202310180016043-20231113184938-i5wen2m.png)​

​![image.png](assets/net-img-202310180016044-20231113184939-dexyzzk.png)​
